// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/dashpay/tenderdash/libs/bytes"
	"github.com/dashpay/tenderdash/rpc/client"
	"github.com/dashpay/tenderdash/rpc/coretypes"
	"github.com/dashpay/tenderdash/types"
	mock "github.com/stretchr/testify/mock"
)

// NewRemoteClient creates a new instance of RemoteClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRemoteClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *RemoteClient {
	mock := &RemoteClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RemoteClient is an autogenerated mock type for the RemoteClient type
type RemoteClient struct {
	mock.Mock
}

type RemoteClient_Expecter struct {
	mock *mock.Mock
}

func (_m *RemoteClient) EXPECT() *RemoteClient_Expecter {
	return &RemoteClient_Expecter{mock: &_m.Mock}
}

// ABCIInfo provides a mock function for the type RemoteClient
func (_mock *RemoteClient) ABCIInfo(context1 context.Context) (*coretypes.ResultABCIInfo, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ABCIInfo")
	}

	var r0 *coretypes.ResultABCIInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultABCIInfo, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultABCIInfo); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultABCIInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_ABCIInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ABCIInfo'
type RemoteClient_ABCIInfo_Call struct {
	*mock.Call
}

// ABCIInfo is a helper method to define mock.On call
//   - context1 context.Context
func (_e *RemoteClient_Expecter) ABCIInfo(context1 interface{}) *RemoteClient_ABCIInfo_Call {
	return &RemoteClient_ABCIInfo_Call{Call: _e.mock.On("ABCIInfo", context1)}
}

func (_c *RemoteClient_ABCIInfo_Call) Run(run func(context1 context.Context)) *RemoteClient_ABCIInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RemoteClient_ABCIInfo_Call) Return(resultABCIInfo *coretypes.ResultABCIInfo, err error) *RemoteClient_ABCIInfo_Call {
	_c.Call.Return(resultABCIInfo, err)
	return _c
}

func (_c *RemoteClient_ABCIInfo_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultABCIInfo, error)) *RemoteClient_ABCIInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ABCIQuery provides a mock function for the type RemoteClient
func (_mock *RemoteClient) ABCIQuery(ctx context.Context, path string, data bytes.HexBytes) (*coretypes.ResultABCIQuery, error) {
	ret := _mock.Called(ctx, path, data)

	if len(ret) == 0 {
		panic("no return value specified for ABCIQuery")
	}

	var r0 *coretypes.ResultABCIQuery
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes) (*coretypes.ResultABCIQuery, error)); ok {
		return returnFunc(ctx, path, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes) *coretypes.ResultABCIQuery); ok {
		r0 = returnFunc(ctx, path, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultABCIQuery)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, bytes.HexBytes) error); ok {
		r1 = returnFunc(ctx, path, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_ABCIQuery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ABCIQuery'
type RemoteClient_ABCIQuery_Call struct {
	*mock.Call
}

// ABCIQuery is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
//   - data bytes.HexBytes
func (_e *RemoteClient_Expecter) ABCIQuery(ctx interface{}, path interface{}, data interface{}) *RemoteClient_ABCIQuery_Call {
	return &RemoteClient_ABCIQuery_Call{Call: _e.mock.On("ABCIQuery", ctx, path, data)}
}

func (_c *RemoteClient_ABCIQuery_Call) Run(run func(ctx context.Context, path string, data bytes.HexBytes)) *RemoteClient_ABCIQuery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bytes.HexBytes
		if args[2] != nil {
			arg2 = args[2].(bytes.HexBytes)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *RemoteClient_ABCIQuery_Call) Return(resultABCIQuery *coretypes.ResultABCIQuery, err error) *RemoteClient_ABCIQuery_Call {
	_c.Call.Return(resultABCIQuery, err)
	return _c
}

func (_c *RemoteClient_ABCIQuery_Call) RunAndReturn(run func(ctx context.Context, path string, data bytes.HexBytes) (*coretypes.ResultABCIQuery, error)) *RemoteClient_ABCIQuery_Call {
	_c.Call.Return(run)
	return _c
}

// ABCIQueryWithOptions provides a mock function for the type RemoteClient
func (_mock *RemoteClient) ABCIQueryWithOptions(ctx context.Context, path string, data bytes.HexBytes, opts client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error) {
	ret := _mock.Called(ctx, path, data, opts)

	if len(ret) == 0 {
		panic("no return value specified for ABCIQueryWithOptions")
	}

	var r0 *coretypes.ResultABCIQuery
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes, client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error)); ok {
		return returnFunc(ctx, path, data, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes, client.ABCIQueryOptions) *coretypes.ResultABCIQuery); ok {
		r0 = returnFunc(ctx, path, data, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultABCIQuery)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, bytes.HexBytes, client.ABCIQueryOptions) error); ok {
		r1 = returnFunc(ctx, path, data, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_ABCIQueryWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ABCIQueryWithOptions'
type RemoteClient_ABCIQueryWithOptions_Call struct {
	*mock.Call
}

// ABCIQueryWithOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
//   - data bytes.HexBytes
//   - opts client.ABCIQueryOptions
func (_e *RemoteClient_Expecter) ABCIQueryWithOptions(ctx interface{}, path interface{}, data interface{}, opts interface{}) *RemoteClient_ABCIQueryWithOptions_Call {
	return &RemoteClient_ABCIQueryWithOptions_Call{Call: _e.mock.On("ABCIQueryWithOptions", ctx, path, data, opts)}
}

func (_c *RemoteClient_ABCIQueryWithOptions_Call) Run(run func(ctx context.Context, path string, data bytes.HexBytes, opts client.ABCIQueryOptions)) *RemoteClient_ABCIQueryWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bytes.HexBytes
		if args[2] != nil {
			arg2 = args[2].(bytes.HexBytes)
		}
		var arg3 client.ABCIQueryOptions
		if args[3] != nil {
			arg3 = args[3].(client.ABCIQueryOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *RemoteClient_ABCIQueryWithOptions_Call) Return(resultABCIQuery *coretypes.ResultABCIQuery, err error) *RemoteClient_ABCIQueryWithOptions_Call {
	_c.Call.Return(resultABCIQuery, err)
	return _c
}

func (_c *RemoteClient_ABCIQueryWithOptions_Call) RunAndReturn(run func(ctx context.Context, path string, data bytes.HexBytes, opts client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error)) *RemoteClient_ABCIQueryWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// Block provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Block(ctx context.Context, height *int64) (*coretypes.ResultBlock, error) {
	ret := _mock.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for Block")
	}

	var r0 *coretypes.ResultBlock
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultBlock, error)); ok {
		return returnFunc(ctx, height)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultBlock); ok {
		r0 = returnFunc(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlock)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = returnFunc(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_Block_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Block'
type RemoteClient_Block_Call struct {
	*mock.Call
}

// Block is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
func (_e *RemoteClient_Expecter) Block(ctx interface{}, height interface{}) *RemoteClient_Block_Call {
	return &RemoteClient_Block_Call{Call: _e.mock.On("Block", ctx, height)}
}

func (_c *RemoteClient_Block_Call) Run(run func(ctx context.Context, height *int64)) *RemoteClient_Block_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *int64
		if args[1] != nil {
			arg1 = args[1].(*int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_Block_Call) Return(resultBlock *coretypes.ResultBlock, err error) *RemoteClient_Block_Call {
	_c.Call.Return(resultBlock, err)
	return _c
}

func (_c *RemoteClient_Block_Call) RunAndReturn(run func(ctx context.Context, height *int64) (*coretypes.ResultBlock, error)) *RemoteClient_Block_Call {
	_c.Call.Return(run)
	return _c
}

// BlockByHash provides a mock function for the type RemoteClient
func (_mock *RemoteClient) BlockByHash(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultBlock, error) {
	ret := _mock.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for BlockByHash")
	}

	var r0 *coretypes.ResultBlock
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes) (*coretypes.ResultBlock, error)); ok {
		return returnFunc(ctx, hash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes) *coretypes.ResultBlock); ok {
		r0 = returnFunc(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlock)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, bytes.HexBytes) error); ok {
		r1 = returnFunc(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_BlockByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockByHash'
type RemoteClient_BlockByHash_Call struct {
	*mock.Call
}

// BlockByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - hash bytes.HexBytes
func (_e *RemoteClient_Expecter) BlockByHash(ctx interface{}, hash interface{}) *RemoteClient_BlockByHash_Call {
	return &RemoteClient_BlockByHash_Call{Call: _e.mock.On("BlockByHash", ctx, hash)}
}

func (_c *RemoteClient_BlockByHash_Call) Run(run func(ctx context.Context, hash bytes.HexBytes)) *RemoteClient_BlockByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 bytes.HexBytes
		if args[1] != nil {
			arg1 = args[1].(bytes.HexBytes)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_BlockByHash_Call) Return(resultBlock *coretypes.ResultBlock, err error) *RemoteClient_BlockByHash_Call {
	_c.Call.Return(resultBlock, err)
	return _c
}

func (_c *RemoteClient_BlockByHash_Call) RunAndReturn(run func(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultBlock, error)) *RemoteClient_BlockByHash_Call {
	_c.Call.Return(run)
	return _c
}

// BlockResults provides a mock function for the type RemoteClient
func (_mock *RemoteClient) BlockResults(ctx context.Context, height *int64) (*coretypes.ResultBlockResults, error) {
	ret := _mock.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for BlockResults")
	}

	var r0 *coretypes.ResultBlockResults
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultBlockResults, error)); ok {
		return returnFunc(ctx, height)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultBlockResults); ok {
		r0 = returnFunc(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlockResults)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = returnFunc(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_BlockResults_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockResults'
type RemoteClient_BlockResults_Call struct {
	*mock.Call
}

// BlockResults is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
func (_e *RemoteClient_Expecter) BlockResults(ctx interface{}, height interface{}) *RemoteClient_BlockResults_Call {
	return &RemoteClient_BlockResults_Call{Call: _e.mock.On("BlockResults", ctx, height)}
}

func (_c *RemoteClient_BlockResults_Call) Run(run func(ctx context.Context, height *int64)) *RemoteClient_BlockResults_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *int64
		if args[1] != nil {
			arg1 = args[1].(*int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_BlockResults_Call) Return(resultBlockResults *coretypes.ResultBlockResults, err error) *RemoteClient_BlockResults_Call {
	_c.Call.Return(resultBlockResults, err)
	return _c
}

func (_c *RemoteClient_BlockResults_Call) RunAndReturn(run func(ctx context.Context, height *int64) (*coretypes.ResultBlockResults, error)) *RemoteClient_BlockResults_Call {
	_c.Call.Return(run)
	return _c
}

// BlockSearch provides a mock function for the type RemoteClient
func (_mock *RemoteClient) BlockSearch(ctx context.Context, query string, page *int, perPage *int, orderBy string) (*coretypes.ResultBlockSearch, error) {
	ret := _mock.Called(ctx, query, page, perPage, orderBy)

	if len(ret) == 0 {
		panic("no return value specified for BlockSearch")
	}

	var r0 *coretypes.ResultBlockSearch
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *int, *int, string) (*coretypes.ResultBlockSearch, error)); ok {
		return returnFunc(ctx, query, page, perPage, orderBy)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *int, *int, string) *coretypes.ResultBlockSearch); ok {
		r0 = returnFunc(ctx, query, page, perPage, orderBy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlockSearch)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, *int, *int, string) error); ok {
		r1 = returnFunc(ctx, query, page, perPage, orderBy)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_BlockSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockSearch'
type RemoteClient_BlockSearch_Call struct {
	*mock.Call
}

// BlockSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - page *int
//   - perPage *int
//   - orderBy string
func (_e *RemoteClient_Expecter) BlockSearch(ctx interface{}, query interface{}, page interface{}, perPage interface{}, orderBy interface{}) *RemoteClient_BlockSearch_Call {
	return &RemoteClient_BlockSearch_Call{Call: _e.mock.On("BlockSearch", ctx, query, page, perPage, orderBy)}
}

func (_c *RemoteClient_BlockSearch_Call) Run(run func(ctx context.Context, query string, page *int, perPage *int, orderBy string)) *RemoteClient_BlockSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *int
		if args[2] != nil {
			arg2 = args[2].(*int)
		}
		var arg3 *int
		if args[3] != nil {
			arg3 = args[3].(*int)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *RemoteClient_BlockSearch_Call) Return(resultBlockSearch *coretypes.ResultBlockSearch, err error) *RemoteClient_BlockSearch_Call {
	_c.Call.Return(resultBlockSearch, err)
	return _c
}

func (_c *RemoteClient_BlockSearch_Call) RunAndReturn(run func(ctx context.Context, query string, page *int, perPage *int, orderBy string) (*coretypes.ResultBlockSearch, error)) *RemoteClient_BlockSearch_Call {
	_c.Call.Return(run)
	return _c
}

// BlockchainInfo provides a mock function for the type RemoteClient
func (_mock *RemoteClient) BlockchainInfo(ctx context.Context, minHeight int64, maxHeight int64) (*coretypes.ResultBlockchainInfo, error) {
	ret := _mock.Called(ctx, minHeight, maxHeight)

	if len(ret) == 0 {
		panic("no return value specified for BlockchainInfo")
	}

	var r0 *coretypes.ResultBlockchainInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int64) (*coretypes.ResultBlockchainInfo, error)); ok {
		return returnFunc(ctx, minHeight, maxHeight)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int64) *coretypes.ResultBlockchainInfo); ok {
		r0 = returnFunc(ctx, minHeight, maxHeight)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlockchainInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = returnFunc(ctx, minHeight, maxHeight)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_BlockchainInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockchainInfo'
type RemoteClient_BlockchainInfo_Call struct {
	*mock.Call
}

// BlockchainInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - minHeight int64
//   - maxHeight int64
func (_e *RemoteClient_Expecter) BlockchainInfo(ctx interface{}, minHeight interface{}, maxHeight interface{}) *RemoteClient_BlockchainInfo_Call {
	return &RemoteClient_BlockchainInfo_Call{Call: _e.mock.On("BlockchainInfo", ctx, minHeight, maxHeight)}
}

func (_c *RemoteClient_BlockchainInfo_Call) Run(run func(ctx context.Context, minHeight int64, maxHeight int64)) *RemoteClient_BlockchainInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *RemoteClient_BlockchainInfo_Call) Return(resultBlockchainInfo *coretypes.ResultBlockchainInfo, err error) *RemoteClient_BlockchainInfo_Call {
	_c.Call.Return(resultBlockchainInfo, err)
	return _c
}

func (_c *RemoteClient_BlockchainInfo_Call) RunAndReturn(run func(ctx context.Context, minHeight int64, maxHeight int64) (*coretypes.ResultBlockchainInfo, error)) *RemoteClient_BlockchainInfo_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastEvidence provides a mock function for the type RemoteClient
func (_mock *RemoteClient) BroadcastEvidence(context1 context.Context, evidence types.Evidence) (*coretypes.ResultBroadcastEvidence, error) {
	ret := _mock.Called(context1, evidence)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastEvidence")
	}

	var r0 *coretypes.ResultBroadcastEvidence
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Evidence) (*coretypes.ResultBroadcastEvidence, error)); ok {
		return returnFunc(context1, evidence)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Evidence) *coretypes.ResultBroadcastEvidence); ok {
		r0 = returnFunc(context1, evidence)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastEvidence)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Evidence) error); ok {
		r1 = returnFunc(context1, evidence)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_BroadcastEvidence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastEvidence'
type RemoteClient_BroadcastEvidence_Call struct {
	*mock.Call
}

// BroadcastEvidence is a helper method to define mock.On call
//   - context1 context.Context
//   - evidence types.Evidence
func (_e *RemoteClient_Expecter) BroadcastEvidence(context1 interface{}, evidence interface{}) *RemoteClient_BroadcastEvidence_Call {
	return &RemoteClient_BroadcastEvidence_Call{Call: _e.mock.On("BroadcastEvidence", context1, evidence)}
}

func (_c *RemoteClient_BroadcastEvidence_Call) Run(run func(context1 context.Context, evidence types.Evidence)) *RemoteClient_BroadcastEvidence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.Evidence
		if args[1] != nil {
			arg1 = args[1].(types.Evidence)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_BroadcastEvidence_Call) Return(resultBroadcastEvidence *coretypes.ResultBroadcastEvidence, err error) *RemoteClient_BroadcastEvidence_Call {
	_c.Call.Return(resultBroadcastEvidence, err)
	return _c
}

func (_c *RemoteClient_BroadcastEvidence_Call) RunAndReturn(run func(context1 context.Context, evidence types.Evidence) (*coretypes.ResultBroadcastEvidence, error)) *RemoteClient_BroadcastEvidence_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastTx provides a mock function for the type RemoteClient
func (_mock *RemoteClient) BroadcastTx(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error) {
	ret := _mock.Called(context1, tx)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastTx")
	}

	var r0 *coretypes.ResultBroadcastTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultBroadcastTx, error)); ok {
		return returnFunc(context1, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultBroadcastTx); ok {
		r0 = returnFunc(context1, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = returnFunc(context1, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_BroadcastTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastTx'
type RemoteClient_BroadcastTx_Call struct {
	*mock.Call
}

// BroadcastTx is a helper method to define mock.On call
//   - context1 context.Context
//   - tx types.Tx
func (_e *RemoteClient_Expecter) BroadcastTx(context1 interface{}, tx interface{}) *RemoteClient_BroadcastTx_Call {
	return &RemoteClient_BroadcastTx_Call{Call: _e.mock.On("BroadcastTx", context1, tx)}
}

func (_c *RemoteClient_BroadcastTx_Call) Run(run func(context1 context.Context, tx types.Tx)) *RemoteClient_BroadcastTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.Tx
		if args[1] != nil {
			arg1 = args[1].(types.Tx)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_BroadcastTx_Call) Return(resultBroadcastTx *coretypes.ResultBroadcastTx, err error) *RemoteClient_BroadcastTx_Call {
	_c.Call.Return(resultBroadcastTx, err)
	return _c
}

func (_c *RemoteClient_BroadcastTx_Call) RunAndReturn(run func(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error)) *RemoteClient_BroadcastTx_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastTxAsync provides a mock function for the type RemoteClient
func (_mock *RemoteClient) BroadcastTxAsync(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error) {
	ret := _mock.Called(context1, tx)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastTxAsync")
	}

	var r0 *coretypes.ResultBroadcastTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultBroadcastTx, error)); ok {
		return returnFunc(context1, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultBroadcastTx); ok {
		r0 = returnFunc(context1, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = returnFunc(context1, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_BroadcastTxAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastTxAsync'
type RemoteClient_BroadcastTxAsync_Call struct {
	*mock.Call
}

// BroadcastTxAsync is a helper method to define mock.On call
//   - context1 context.Context
//   - tx types.Tx
func (_e *RemoteClient_Expecter) BroadcastTxAsync(context1 interface{}, tx interface{}) *RemoteClient_BroadcastTxAsync_Call {
	return &RemoteClient_BroadcastTxAsync_Call{Call: _e.mock.On("BroadcastTxAsync", context1, tx)}
}

func (_c *RemoteClient_BroadcastTxAsync_Call) Run(run func(context1 context.Context, tx types.Tx)) *RemoteClient_BroadcastTxAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.Tx
		if args[1] != nil {
			arg1 = args[1].(types.Tx)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_BroadcastTxAsync_Call) Return(resultBroadcastTx *coretypes.ResultBroadcastTx, err error) *RemoteClient_BroadcastTxAsync_Call {
	_c.Call.Return(resultBroadcastTx, err)
	return _c
}

func (_c *RemoteClient_BroadcastTxAsync_Call) RunAndReturn(run func(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error)) *RemoteClient_BroadcastTxAsync_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastTxCommit provides a mock function for the type RemoteClient
func (_mock *RemoteClient) BroadcastTxCommit(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTxCommit, error) {
	ret := _mock.Called(context1, tx)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastTxCommit")
	}

	var r0 *coretypes.ResultBroadcastTxCommit
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultBroadcastTxCommit, error)); ok {
		return returnFunc(context1, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultBroadcastTxCommit); ok {
		r0 = returnFunc(context1, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastTxCommit)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = returnFunc(context1, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_BroadcastTxCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastTxCommit'
type RemoteClient_BroadcastTxCommit_Call struct {
	*mock.Call
}

// BroadcastTxCommit is a helper method to define mock.On call
//   - context1 context.Context
//   - tx types.Tx
func (_e *RemoteClient_Expecter) BroadcastTxCommit(context1 interface{}, tx interface{}) *RemoteClient_BroadcastTxCommit_Call {
	return &RemoteClient_BroadcastTxCommit_Call{Call: _e.mock.On("BroadcastTxCommit", context1, tx)}
}

func (_c *RemoteClient_BroadcastTxCommit_Call) Run(run func(context1 context.Context, tx types.Tx)) *RemoteClient_BroadcastTxCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.Tx
		if args[1] != nil {
			arg1 = args[1].(types.Tx)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_BroadcastTxCommit_Call) Return(resultBroadcastTxCommit *coretypes.ResultBroadcastTxCommit, err error) *RemoteClient_BroadcastTxCommit_Call {
	_c.Call.Return(resultBroadcastTxCommit, err)
	return _c
}

func (_c *RemoteClient_BroadcastTxCommit_Call) RunAndReturn(run func(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTxCommit, error)) *RemoteClient_BroadcastTxCommit_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastTxSync provides a mock function for the type RemoteClient
func (_mock *RemoteClient) BroadcastTxSync(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error) {
	ret := _mock.Called(context1, tx)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastTxSync")
	}

	var r0 *coretypes.ResultBroadcastTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultBroadcastTx, error)); ok {
		return returnFunc(context1, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultBroadcastTx); ok {
		r0 = returnFunc(context1, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = returnFunc(context1, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_BroadcastTxSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastTxSync'
type RemoteClient_BroadcastTxSync_Call struct {
	*mock.Call
}

// BroadcastTxSync is a helper method to define mock.On call
//   - context1 context.Context
//   - tx types.Tx
func (_e *RemoteClient_Expecter) BroadcastTxSync(context1 interface{}, tx interface{}) *RemoteClient_BroadcastTxSync_Call {
	return &RemoteClient_BroadcastTxSync_Call{Call: _e.mock.On("BroadcastTxSync", context1, tx)}
}

func (_c *RemoteClient_BroadcastTxSync_Call) Run(run func(context1 context.Context, tx types.Tx)) *RemoteClient_BroadcastTxSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.Tx
		if args[1] != nil {
			arg1 = args[1].(types.Tx)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_BroadcastTxSync_Call) Return(resultBroadcastTx *coretypes.ResultBroadcastTx, err error) *RemoteClient_BroadcastTxSync_Call {
	_c.Call.Return(resultBroadcastTx, err)
	return _c
}

func (_c *RemoteClient_BroadcastTxSync_Call) RunAndReturn(run func(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error)) *RemoteClient_BroadcastTxSync_Call {
	_c.Call.Return(run)
	return _c
}

// CheckTx provides a mock function for the type RemoteClient
func (_mock *RemoteClient) CheckTx(context1 context.Context, tx types.Tx) (*coretypes.ResultCheckTx, error) {
	ret := _mock.Called(context1, tx)

	if len(ret) == 0 {
		panic("no return value specified for CheckTx")
	}

	var r0 *coretypes.ResultCheckTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultCheckTx, error)); ok {
		return returnFunc(context1, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultCheckTx); ok {
		r0 = returnFunc(context1, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultCheckTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = returnFunc(context1, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_CheckTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckTx'
type RemoteClient_CheckTx_Call struct {
	*mock.Call
}

// CheckTx is a helper method to define mock.On call
//   - context1 context.Context
//   - tx types.Tx
func (_e *RemoteClient_Expecter) CheckTx(context1 interface{}, tx interface{}) *RemoteClient_CheckTx_Call {
	return &RemoteClient_CheckTx_Call{Call: _e.mock.On("CheckTx", context1, tx)}
}

func (_c *RemoteClient_CheckTx_Call) Run(run func(context1 context.Context, tx types.Tx)) *RemoteClient_CheckTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.Tx
		if args[1] != nil {
			arg1 = args[1].(types.Tx)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_CheckTx_Call) Return(resultCheckTx *coretypes.ResultCheckTx, err error) *RemoteClient_CheckTx_Call {
	_c.Call.Return(resultCheckTx, err)
	return _c
}

func (_c *RemoteClient_CheckTx_Call) RunAndReturn(run func(context1 context.Context, tx types.Tx) (*coretypes.ResultCheckTx, error)) *RemoteClient_CheckTx_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Commit(ctx context.Context, height *int64) (*coretypes.ResultCommit, error) {
	ret := _mock.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 *coretypes.ResultCommit
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultCommit, error)); ok {
		return returnFunc(ctx, height)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultCommit); ok {
		r0 = returnFunc(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultCommit)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = returnFunc(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type RemoteClient_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
func (_e *RemoteClient_Expecter) Commit(ctx interface{}, height interface{}) *RemoteClient_Commit_Call {
	return &RemoteClient_Commit_Call{Call: _e.mock.On("Commit", ctx, height)}
}

func (_c *RemoteClient_Commit_Call) Run(run func(ctx context.Context, height *int64)) *RemoteClient_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *int64
		if args[1] != nil {
			arg1 = args[1].(*int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_Commit_Call) Return(resultCommit *coretypes.ResultCommit, err error) *RemoteClient_Commit_Call {
	_c.Call.Return(resultCommit, err)
	return _c
}

func (_c *RemoteClient_Commit_Call) RunAndReturn(run func(ctx context.Context, height *int64) (*coretypes.ResultCommit, error)) *RemoteClient_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// ConsensusParams provides a mock function for the type RemoteClient
func (_mock *RemoteClient) ConsensusParams(ctx context.Context, height *int64) (*coretypes.ResultConsensusParams, error) {
	ret := _mock.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for ConsensusParams")
	}

	var r0 *coretypes.ResultConsensusParams
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultConsensusParams, error)); ok {
		return returnFunc(ctx, height)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultConsensusParams); ok {
		r0 = returnFunc(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultConsensusParams)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = returnFunc(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_ConsensusParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsensusParams'
type RemoteClient_ConsensusParams_Call struct {
	*mock.Call
}

// ConsensusParams is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
func (_e *RemoteClient_Expecter) ConsensusParams(ctx interface{}, height interface{}) *RemoteClient_ConsensusParams_Call {
	return &RemoteClient_ConsensusParams_Call{Call: _e.mock.On("ConsensusParams", ctx, height)}
}

func (_c *RemoteClient_ConsensusParams_Call) Run(run func(ctx context.Context, height *int64)) *RemoteClient_ConsensusParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *int64
		if args[1] != nil {
			arg1 = args[1].(*int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_ConsensusParams_Call) Return(resultConsensusParams *coretypes.ResultConsensusParams, err error) *RemoteClient_ConsensusParams_Call {
	_c.Call.Return(resultConsensusParams, err)
	return _c
}

func (_c *RemoteClient_ConsensusParams_Call) RunAndReturn(run func(ctx context.Context, height *int64) (*coretypes.ResultConsensusParams, error)) *RemoteClient_ConsensusParams_Call {
	_c.Call.Return(run)
	return _c
}

// ConsensusState provides a mock function for the type RemoteClient
func (_mock *RemoteClient) ConsensusState(context1 context.Context) (*coretypes.ResultConsensusState, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ConsensusState")
	}

	var r0 *coretypes.ResultConsensusState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultConsensusState, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultConsensusState); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultConsensusState)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_ConsensusState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsensusState'
type RemoteClient_ConsensusState_Call struct {
	*mock.Call
}

// ConsensusState is a helper method to define mock.On call
//   - context1 context.Context
func (_e *RemoteClient_Expecter) ConsensusState(context1 interface{}) *RemoteClient_ConsensusState_Call {
	return &RemoteClient_ConsensusState_Call{Call: _e.mock.On("ConsensusState", context1)}
}

func (_c *RemoteClient_ConsensusState_Call) Run(run func(context1 context.Context)) *RemoteClient_ConsensusState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RemoteClient_ConsensusState_Call) Return(resultConsensusState *coretypes.ResultConsensusState, err error) *RemoteClient_ConsensusState_Call {
	_c.Call.Return(resultConsensusState, err)
	return _c
}

func (_c *RemoteClient_ConsensusState_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultConsensusState, error)) *RemoteClient_ConsensusState_Call {
	_c.Call.Return(run)
	return _c
}

// DumpConsensusState provides a mock function for the type RemoteClient
func (_mock *RemoteClient) DumpConsensusState(context1 context.Context) (*coretypes.ResultDumpConsensusState, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for DumpConsensusState")
	}

	var r0 *coretypes.ResultDumpConsensusState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultDumpConsensusState, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultDumpConsensusState); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultDumpConsensusState)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_DumpConsensusState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DumpConsensusState'
type RemoteClient_DumpConsensusState_Call struct {
	*mock.Call
}

// DumpConsensusState is a helper method to define mock.On call
//   - context1 context.Context
func (_e *RemoteClient_Expecter) DumpConsensusState(context1 interface{}) *RemoteClient_DumpConsensusState_Call {
	return &RemoteClient_DumpConsensusState_Call{Call: _e.mock.On("DumpConsensusState", context1)}
}

func (_c *RemoteClient_DumpConsensusState_Call) Run(run func(context1 context.Context)) *RemoteClient_DumpConsensusState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RemoteClient_DumpConsensusState_Call) Return(resultDumpConsensusState *coretypes.ResultDumpConsensusState, err error) *RemoteClient_DumpConsensusState_Call {
	_c.Call.Return(resultDumpConsensusState, err)
	return _c
}

func (_c *RemoteClient_DumpConsensusState_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultDumpConsensusState, error)) *RemoteClient_DumpConsensusState_Call {
	_c.Call.Return(run)
	return _c
}

// Events provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Events(ctx context.Context, req *coretypes.RequestEvents) (*coretypes.ResultEvents, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Events")
	}

	var r0 *coretypes.ResultEvents
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *coretypes.RequestEvents) (*coretypes.ResultEvents, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *coretypes.RequestEvents) *coretypes.ResultEvents); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultEvents)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *coretypes.RequestEvents) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_Events_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Events'
type RemoteClient_Events_Call struct {
	*mock.Call
}

// Events is a helper method to define mock.On call
//   - ctx context.Context
//   - req *coretypes.RequestEvents
func (_e *RemoteClient_Expecter) Events(ctx interface{}, req interface{}) *RemoteClient_Events_Call {
	return &RemoteClient_Events_Call{Call: _e.mock.On("Events", ctx, req)}
}

func (_c *RemoteClient_Events_Call) Run(run func(ctx context.Context, req *coretypes.RequestEvents)) *RemoteClient_Events_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *coretypes.RequestEvents
		if args[1] != nil {
			arg1 = args[1].(*coretypes.RequestEvents)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_Events_Call) Return(resultEvents *coretypes.ResultEvents, err error) *RemoteClient_Events_Call {
	_c.Call.Return(resultEvents, err)
	return _c
}

func (_c *RemoteClient_Events_Call) RunAndReturn(run func(ctx context.Context, req *coretypes.RequestEvents) (*coretypes.ResultEvents, error)) *RemoteClient_Events_Call {
	_c.Call.Return(run)
	return _c
}

// Genesis provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Genesis(context1 context.Context) (*coretypes.ResultGenesis, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Genesis")
	}

	var r0 *coretypes.ResultGenesis
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultGenesis, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultGenesis); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultGenesis)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_Genesis_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Genesis'
type RemoteClient_Genesis_Call struct {
	*mock.Call
}

// Genesis is a helper method to define mock.On call
//   - context1 context.Context
func (_e *RemoteClient_Expecter) Genesis(context1 interface{}) *RemoteClient_Genesis_Call {
	return &RemoteClient_Genesis_Call{Call: _e.mock.On("Genesis", context1)}
}

func (_c *RemoteClient_Genesis_Call) Run(run func(context1 context.Context)) *RemoteClient_Genesis_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RemoteClient_Genesis_Call) Return(resultGenesis *coretypes.ResultGenesis, err error) *RemoteClient_Genesis_Call {
	_c.Call.Return(resultGenesis, err)
	return _c
}

func (_c *RemoteClient_Genesis_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultGenesis, error)) *RemoteClient_Genesis_Call {
	_c.Call.Return(run)
	return _c
}

// GenesisChunked provides a mock function for the type RemoteClient
func (_mock *RemoteClient) GenesisChunked(context1 context.Context, v uint) (*coretypes.ResultGenesisChunk, error) {
	ret := _mock.Called(context1, v)

	if len(ret) == 0 {
		panic("no return value specified for GenesisChunked")
	}

	var r0 *coretypes.ResultGenesisChunk
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) (*coretypes.ResultGenesisChunk, error)); ok {
		return returnFunc(context1, v)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) *coretypes.ResultGenesisChunk); ok {
		r0 = returnFunc(context1, v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultGenesisChunk)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = returnFunc(context1, v)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_GenesisChunked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenesisChunked'
type RemoteClient_GenesisChunked_Call struct {
	*mock.Call
}

// GenesisChunked is a helper method to define mock.On call
//   - context1 context.Context
//   - v uint
func (_e *RemoteClient_Expecter) GenesisChunked(context1 interface{}, v interface{}) *RemoteClient_GenesisChunked_Call {
	return &RemoteClient_GenesisChunked_Call{Call: _e.mock.On("GenesisChunked", context1, v)}
}

func (_c *RemoteClient_GenesisChunked_Call) Run(run func(context1 context.Context, v uint)) *RemoteClient_GenesisChunked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_GenesisChunked_Call) Return(resultGenesisChunk *coretypes.ResultGenesisChunk, err error) *RemoteClient_GenesisChunked_Call {
	_c.Call.Return(resultGenesisChunk, err)
	return _c
}

func (_c *RemoteClient_GenesisChunked_Call) RunAndReturn(run func(context1 context.Context, v uint) (*coretypes.ResultGenesisChunk, error)) *RemoteClient_GenesisChunked_Call {
	_c.Call.Return(run)
	return _c
}

// Header provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Header(ctx context.Context, height *int64) (*coretypes.ResultHeader, error) {
	ret := _mock.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for Header")
	}

	var r0 *coretypes.ResultHeader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultHeader, error)); ok {
		return returnFunc(ctx, height)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultHeader); ok {
		r0 = returnFunc(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultHeader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = returnFunc(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_Header_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Header'
type RemoteClient_Header_Call struct {
	*mock.Call
}

// Header is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
func (_e *RemoteClient_Expecter) Header(ctx interface{}, height interface{}) *RemoteClient_Header_Call {
	return &RemoteClient_Header_Call{Call: _e.mock.On("Header", ctx, height)}
}

func (_c *RemoteClient_Header_Call) Run(run func(ctx context.Context, height *int64)) *RemoteClient_Header_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *int64
		if args[1] != nil {
			arg1 = args[1].(*int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_Header_Call) Return(resultHeader *coretypes.ResultHeader, err error) *RemoteClient_Header_Call {
	_c.Call.Return(resultHeader, err)
	return _c
}

func (_c *RemoteClient_Header_Call) RunAndReturn(run func(ctx context.Context, height *int64) (*coretypes.ResultHeader, error)) *RemoteClient_Header_Call {
	_c.Call.Return(run)
	return _c
}

// HeaderByHash provides a mock function for the type RemoteClient
func (_mock *RemoteClient) HeaderByHash(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultHeader, error) {
	ret := _mock.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for HeaderByHash")
	}

	var r0 *coretypes.ResultHeader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes) (*coretypes.ResultHeader, error)); ok {
		return returnFunc(ctx, hash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes) *coretypes.ResultHeader); ok {
		r0 = returnFunc(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultHeader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, bytes.HexBytes) error); ok {
		r1 = returnFunc(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_HeaderByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HeaderByHash'
type RemoteClient_HeaderByHash_Call struct {
	*mock.Call
}

// HeaderByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - hash bytes.HexBytes
func (_e *RemoteClient_Expecter) HeaderByHash(ctx interface{}, hash interface{}) *RemoteClient_HeaderByHash_Call {
	return &RemoteClient_HeaderByHash_Call{Call: _e.mock.On("HeaderByHash", ctx, hash)}
}

func (_c *RemoteClient_HeaderByHash_Call) Run(run func(ctx context.Context, hash bytes.HexBytes)) *RemoteClient_HeaderByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 bytes.HexBytes
		if args[1] != nil {
			arg1 = args[1].(bytes.HexBytes)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_HeaderByHash_Call) Return(resultHeader *coretypes.ResultHeader, err error) *RemoteClient_HeaderByHash_Call {
	_c.Call.Return(resultHeader, err)
	return _c
}

func (_c *RemoteClient_HeaderByHash_Call) RunAndReturn(run func(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultHeader, error)) *RemoteClient_HeaderByHash_Call {
	_c.Call.Return(run)
	return _c
}

// Health provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Health(context1 context.Context) (*coretypes.ResultHealth, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Health")
	}

	var r0 *coretypes.ResultHealth
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultHealth, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultHealth); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultHealth)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_Health_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Health'
type RemoteClient_Health_Call struct {
	*mock.Call
}

// Health is a helper method to define mock.On call
//   - context1 context.Context
func (_e *RemoteClient_Expecter) Health(context1 interface{}) *RemoteClient_Health_Call {
	return &RemoteClient_Health_Call{Call: _e.mock.On("Health", context1)}
}

func (_c *RemoteClient_Health_Call) Run(run func(context1 context.Context)) *RemoteClient_Health_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RemoteClient_Health_Call) Return(resultHealth *coretypes.ResultHealth, err error) *RemoteClient_Health_Call {
	_c.Call.Return(resultHealth, err)
	return _c
}

func (_c *RemoteClient_Health_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultHealth, error)) *RemoteClient_Health_Call {
	_c.Call.Return(run)
	return _c
}

// NetInfo provides a mock function for the type RemoteClient
func (_mock *RemoteClient) NetInfo(context1 context.Context) (*coretypes.ResultNetInfo, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for NetInfo")
	}

	var r0 *coretypes.ResultNetInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultNetInfo, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultNetInfo); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultNetInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_NetInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetInfo'
type RemoteClient_NetInfo_Call struct {
	*mock.Call
}

// NetInfo is a helper method to define mock.On call
//   - context1 context.Context
func (_e *RemoteClient_Expecter) NetInfo(context1 interface{}) *RemoteClient_NetInfo_Call {
	return &RemoteClient_NetInfo_Call{Call: _e.mock.On("NetInfo", context1)}
}

func (_c *RemoteClient_NetInfo_Call) Run(run func(context1 context.Context)) *RemoteClient_NetInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RemoteClient_NetInfo_Call) Return(resultNetInfo *coretypes.ResultNetInfo, err error) *RemoteClient_NetInfo_Call {
	_c.Call.Return(resultNetInfo, err)
	return _c
}

func (_c *RemoteClient_NetInfo_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultNetInfo, error)) *RemoteClient_NetInfo_Call {
	_c.Call.Return(run)
	return _c
}

// NumUnconfirmedTxs provides a mock function for the type RemoteClient
func (_mock *RemoteClient) NumUnconfirmedTxs(context1 context.Context) (*coretypes.ResultUnconfirmedTxs, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for NumUnconfirmedTxs")
	}

	var r0 *coretypes.ResultUnconfirmedTxs
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultUnconfirmedTxs, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultUnconfirmedTxs); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultUnconfirmedTxs)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_NumUnconfirmedTxs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NumUnconfirmedTxs'
type RemoteClient_NumUnconfirmedTxs_Call struct {
	*mock.Call
}

// NumUnconfirmedTxs is a helper method to define mock.On call
//   - context1 context.Context
func (_e *RemoteClient_Expecter) NumUnconfirmedTxs(context1 interface{}) *RemoteClient_NumUnconfirmedTxs_Call {
	return &RemoteClient_NumUnconfirmedTxs_Call{Call: _e.mock.On("NumUnconfirmedTxs", context1)}
}

func (_c *RemoteClient_NumUnconfirmedTxs_Call) Run(run func(context1 context.Context)) *RemoteClient_NumUnconfirmedTxs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RemoteClient_NumUnconfirmedTxs_Call) Return(resultUnconfirmedTxs *coretypes.ResultUnconfirmedTxs, err error) *RemoteClient_NumUnconfirmedTxs_Call {
	_c.Call.Return(resultUnconfirmedTxs, err)
	return _c
}

func (_c *RemoteClient_NumUnconfirmedTxs_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultUnconfirmedTxs, error)) *RemoteClient_NumUnconfirmedTxs_Call {
	_c.Call.Return(run)
	return _c
}

// Remote provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Remote() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Remote")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// RemoteClient_Remote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remote'
type RemoteClient_Remote_Call struct {
	*mock.Call
}

// Remote is a helper method to define mock.On call
func (_e *RemoteClient_Expecter) Remote() *RemoteClient_Remote_Call {
	return &RemoteClient_Remote_Call{Call: _e.mock.On("Remote")}
}

func (_c *RemoteClient_Remote_Call) Run(run func()) *RemoteClient_Remote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RemoteClient_Remote_Call) Return(s string) *RemoteClient_Remote_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *RemoteClient_Remote_Call) RunAndReturn(run func() string) *RemoteClient_Remote_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveTx provides a mock function for the type RemoteClient
func (_mock *RemoteClient) RemoveTx(context1 context.Context, txKey types.TxKey) error {
	ret := _mock.Called(context1, txKey)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTx")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TxKey) error); ok {
		r0 = returnFunc(context1, txKey)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// RemoteClient_RemoveTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveTx'
type RemoteClient_RemoveTx_Call struct {
	*mock.Call
}

// RemoveTx is a helper method to define mock.On call
//   - context1 context.Context
//   - txKey types.TxKey
func (_e *RemoteClient_Expecter) RemoveTx(context1 interface{}, txKey interface{}) *RemoteClient_RemoveTx_Call {
	return &RemoteClient_RemoveTx_Call{Call: _e.mock.On("RemoveTx", context1, txKey)}
}

func (_c *RemoteClient_RemoveTx_Call) Run(run func(context1 context.Context, txKey types.TxKey)) *RemoteClient_RemoveTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.TxKey
		if args[1] != nil {
			arg1 = args[1].(types.TxKey)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_RemoveTx_Call) Return(err error) *RemoteClient_RemoveTx_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *RemoteClient_RemoveTx_Call) RunAndReturn(run func(context1 context.Context, txKey types.TxKey) error) *RemoteClient_RemoveTx_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Start(context1 context.Context) error {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// RemoteClient_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type RemoteClient_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - context1 context.Context
func (_e *RemoteClient_Expecter) Start(context1 interface{}) *RemoteClient_Start_Call {
	return &RemoteClient_Start_Call{Call: _e.mock.On("Start", context1)}
}

func (_c *RemoteClient_Start_Call) Run(run func(context1 context.Context)) *RemoteClient_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RemoteClient_Start_Call) Return(err error) *RemoteClient_Start_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *RemoteClient_Start_Call) RunAndReturn(run func(context1 context.Context) error) *RemoteClient_Start_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Status(context1 context.Context) (*coretypes.ResultStatus, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 *coretypes.ResultStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultStatus, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultStatus); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type RemoteClient_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - context1 context.Context
func (_e *RemoteClient_Expecter) Status(context1 interface{}) *RemoteClient_Status_Call {
	return &RemoteClient_Status_Call{Call: _e.mock.On("Status", context1)}
}

func (_c *RemoteClient_Status_Call) Run(run func(context1 context.Context)) *RemoteClient_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *RemoteClient_Status_Call) Return(resultStatus *coretypes.ResultStatus, err error) *RemoteClient_Status_Call {
	_c.Call.Return(resultStatus, err)
	return _c
}

func (_c *RemoteClient_Status_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultStatus, error)) *RemoteClient_Status_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Subscribe(ctx context.Context, subscriber string, query string, outCapacity ...int) (<-chan coretypes.ResultEvent, error) {
	var tmpRet mock.Arguments
	if len(outCapacity) > 0 {
		tmpRet = _mock.Called(ctx, subscriber, query, outCapacity)
	} else {
		tmpRet = _mock.Called(ctx, subscriber, query)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 <-chan coretypes.ResultEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, ...int) (<-chan coretypes.ResultEvent, error)); ok {
		return returnFunc(ctx, subscriber, query, outCapacity...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, ...int) <-chan coretypes.ResultEvent); ok {
		r0 = returnFunc(ctx, subscriber, query, outCapacity...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan coretypes.ResultEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, ...int) error); ok {
		r1 = returnFunc(ctx, subscriber, query, outCapacity...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type RemoteClient_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriber string
//   - query string
//   - outCapacity ...int
func (_e *RemoteClient_Expecter) Subscribe(ctx interface{}, subscriber interface{}, query interface{}, outCapacity ...interface{}) *RemoteClient_Subscribe_Call {
	return &RemoteClient_Subscribe_Call{Call: _e.mock.On("Subscribe",
		append([]interface{}{ctx, subscriber, query}, outCapacity...)...)}
}

func (_c *RemoteClient_Subscribe_Call) Run(run func(ctx context.Context, subscriber string, query string, outCapacity ...int)) *RemoteClient_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 []int
		var variadicArgs []int
		if len(args) > 3 {
			variadicArgs = args[3].([]int)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *RemoteClient_Subscribe_Call) Return(out <-chan coretypes.ResultEvent, err error) *RemoteClient_Subscribe_Call {
	_c.Call.Return(out, err)
	return _c
}

func (_c *RemoteClient_Subscribe_Call) RunAndReturn(run func(ctx context.Context, subscriber string, query string, outCapacity ...int) (<-chan coretypes.ResultEvent, error)) *RemoteClient_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// Tx provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Tx(ctx context.Context, hash bytes.HexBytes, prove bool) (*coretypes.ResultTx, error) {
	ret := _mock.Called(ctx, hash, prove)

	if len(ret) == 0 {
		panic("no return value specified for Tx")
	}

	var r0 *coretypes.ResultTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes, bool) (*coretypes.ResultTx, error)); ok {
		return returnFunc(ctx, hash, prove)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes, bool) *coretypes.ResultTx); ok {
		r0 = returnFunc(ctx, hash, prove)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, bytes.HexBytes, bool) error); ok {
		r1 = returnFunc(ctx, hash, prove)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_Tx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Tx'
type RemoteClient_Tx_Call struct {
	*mock.Call
}

// Tx is a helper method to define mock.On call
//   - ctx context.Context
//   - hash bytes.HexBytes
//   - prove bool
func (_e *RemoteClient_Expecter) Tx(ctx interface{}, hash interface{}, prove interface{}) *RemoteClient_Tx_Call {
	return &RemoteClient_Tx_Call{Call: _e.mock.On("Tx", ctx, hash, prove)}
}

func (_c *RemoteClient_Tx_Call) Run(run func(ctx context.Context, hash bytes.HexBytes, prove bool)) *RemoteClient_Tx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 bytes.HexBytes
		if args[1] != nil {
			arg1 = args[1].(bytes.HexBytes)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *RemoteClient_Tx_Call) Return(resultTx *coretypes.ResultTx, err error) *RemoteClient_Tx_Call {
	_c.Call.Return(resultTx, err)
	return _c
}

func (_c *RemoteClient_Tx_Call) RunAndReturn(run func(ctx context.Context, hash bytes.HexBytes, prove bool) (*coretypes.ResultTx, error)) *RemoteClient_Tx_Call {
	_c.Call.Return(run)
	return _c
}

// TxSearch provides a mock function for the type RemoteClient
func (_mock *RemoteClient) TxSearch(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string) (*coretypes.ResultTxSearch, error) {
	ret := _mock.Called(ctx, query, prove, page, perPage, orderBy)

	if len(ret) == 0 {
		panic("no return value specified for TxSearch")
	}

	var r0 *coretypes.ResultTxSearch
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool, *int, *int, string) (*coretypes.ResultTxSearch, error)); ok {
		return returnFunc(ctx, query, prove, page, perPage, orderBy)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool, *int, *int, string) *coretypes.ResultTxSearch); ok {
		r0 = returnFunc(ctx, query, prove, page, perPage, orderBy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultTxSearch)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, bool, *int, *int, string) error); ok {
		r1 = returnFunc(ctx, query, prove, page, perPage, orderBy)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_TxSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxSearch'
type RemoteClient_TxSearch_Call struct {
	*mock.Call
}

// TxSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - prove bool
//   - page *int
//   - perPage *int
//   - orderBy string
func (_e *RemoteClient_Expecter) TxSearch(ctx interface{}, query interface{}, prove interface{}, page interface{}, perPage interface{}, orderBy interface{}) *RemoteClient_TxSearch_Call {
	return &RemoteClient_TxSearch_Call{Call: _e.mock.On("TxSearch", ctx, query, prove, page, perPage, orderBy)}
}

func (_c *RemoteClient_TxSearch_Call) Run(run func(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string)) *RemoteClient_TxSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		var arg3 *int
		if args[3] != nil {
			arg3 = args[3].(*int)
		}
		var arg4 *int
		if args[4] != nil {
			arg4 = args[4].(*int)
		}
		var arg5 string
		if args[5] != nil {
			arg5 = args[5].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *RemoteClient_TxSearch_Call) Return(resultTxSearch *coretypes.ResultTxSearch, err error) *RemoteClient_TxSearch_Call {
	_c.Call.Return(resultTxSearch, err)
	return _c
}

func (_c *RemoteClient_TxSearch_Call) RunAndReturn(run func(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string) (*coretypes.ResultTxSearch, error)) *RemoteClient_TxSearch_Call {
	_c.Call.Return(run)
	return _c
}

// UnconfirmedTx provides a mock function for the type RemoteClient
func (_mock *RemoteClient) UnconfirmedTx(ctx context.Context, txHash []byte) (*coretypes.ResultUnconfirmedTx, error) {
	ret := _mock.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for UnconfirmedTx")
	}

	var r0 *coretypes.ResultUnconfirmedTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []byte) (*coretypes.ResultUnconfirmedTx, error)); ok {
		return returnFunc(ctx, txHash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []byte) *coretypes.ResultUnconfirmedTx); ok {
		r0 = returnFunc(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultUnconfirmedTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []byte) error); ok {
		r1 = returnFunc(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_UnconfirmedTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnconfirmedTx'
type RemoteClient_UnconfirmedTx_Call struct {
	*mock.Call
}

// UnconfirmedTx is a helper method to define mock.On call
//   - ctx context.Context
//   - txHash []byte
func (_e *RemoteClient_Expecter) UnconfirmedTx(ctx interface{}, txHash interface{}) *RemoteClient_UnconfirmedTx_Call {
	return &RemoteClient_UnconfirmedTx_Call{Call: _e.mock.On("UnconfirmedTx", ctx, txHash)}
}

func (_c *RemoteClient_UnconfirmedTx_Call) Run(run func(ctx context.Context, txHash []byte)) *RemoteClient_UnconfirmedTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_UnconfirmedTx_Call) Return(resultUnconfirmedTx *coretypes.ResultUnconfirmedTx, err error) *RemoteClient_UnconfirmedTx_Call {
	_c.Call.Return(resultUnconfirmedTx, err)
	return _c
}

func (_c *RemoteClient_UnconfirmedTx_Call) RunAndReturn(run func(ctx context.Context, txHash []byte) (*coretypes.ResultUnconfirmedTx, error)) *RemoteClient_UnconfirmedTx_Call {
	_c.Call.Return(run)
	return _c
}

// UnconfirmedTxs provides a mock function for the type RemoteClient
func (_mock *RemoteClient) UnconfirmedTxs(ctx context.Context, page *int, perPage *int) (*coretypes.ResultUnconfirmedTxs, error) {
	ret := _mock.Called(ctx, page, perPage)

	if len(ret) == 0 {
		panic("no return value specified for UnconfirmedTxs")
	}

	var r0 *coretypes.ResultUnconfirmedTxs
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int, *int) (*coretypes.ResultUnconfirmedTxs, error)); ok {
		return returnFunc(ctx, page, perPage)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int, *int) *coretypes.ResultUnconfirmedTxs); ok {
		r0 = returnFunc(ctx, page, perPage)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultUnconfirmedTxs)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int, *int) error); ok {
		r1 = returnFunc(ctx, page, perPage)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_UnconfirmedTxs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnconfirmedTxs'
type RemoteClient_UnconfirmedTxs_Call struct {
	*mock.Call
}

// UnconfirmedTxs is a helper method to define mock.On call
//   - ctx context.Context
//   - page *int
//   - perPage *int
func (_e *RemoteClient_Expecter) UnconfirmedTxs(ctx interface{}, page interface{}, perPage interface{}) *RemoteClient_UnconfirmedTxs_Call {
	return &RemoteClient_UnconfirmedTxs_Call{Call: _e.mock.On("UnconfirmedTxs", ctx, page, perPage)}
}

func (_c *RemoteClient_UnconfirmedTxs_Call) Run(run func(ctx context.Context, page *int, perPage *int)) *RemoteClient_UnconfirmedTxs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *int
		if args[1] != nil {
			arg1 = args[1].(*int)
		}
		var arg2 *int
		if args[2] != nil {
			arg2 = args[2].(*int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *RemoteClient_UnconfirmedTxs_Call) Return(resultUnconfirmedTxs *coretypes.ResultUnconfirmedTxs, err error) *RemoteClient_UnconfirmedTxs_Call {
	_c.Call.Return(resultUnconfirmedTxs, err)
	return _c
}

func (_c *RemoteClient_UnconfirmedTxs_Call) RunAndReturn(run func(ctx context.Context, page *int, perPage *int) (*coretypes.ResultUnconfirmedTxs, error)) *RemoteClient_UnconfirmedTxs_Call {
	_c.Call.Return(run)
	return _c
}

// Unsubscribe provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Unsubscribe(ctx context.Context, subscriber string, query string) error {
	ret := _mock.Called(ctx, subscriber, query)

	if len(ret) == 0 {
		panic("no return value specified for Unsubscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, subscriber, query)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// RemoteClient_Unsubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unsubscribe'
type RemoteClient_Unsubscribe_Call struct {
	*mock.Call
}

// Unsubscribe is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriber string
//   - query string
func (_e *RemoteClient_Expecter) Unsubscribe(ctx interface{}, subscriber interface{}, query interface{}) *RemoteClient_Unsubscribe_Call {
	return &RemoteClient_Unsubscribe_Call{Call: _e.mock.On("Unsubscribe", ctx, subscriber, query)}
}

func (_c *RemoteClient_Unsubscribe_Call) Run(run func(ctx context.Context, subscriber string, query string)) *RemoteClient_Unsubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *RemoteClient_Unsubscribe_Call) Return(err error) *RemoteClient_Unsubscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *RemoteClient_Unsubscribe_Call) RunAndReturn(run func(ctx context.Context, subscriber string, query string) error) *RemoteClient_Unsubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeAll provides a mock function for the type RemoteClient
func (_mock *RemoteClient) UnsubscribeAll(ctx context.Context, subscriber string) error {
	ret := _mock.Called(ctx, subscriber)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, subscriber)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// RemoteClient_UnsubscribeAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeAll'
type RemoteClient_UnsubscribeAll_Call struct {
	*mock.Call
}

// UnsubscribeAll is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriber string
func (_e *RemoteClient_Expecter) UnsubscribeAll(ctx interface{}, subscriber interface{}) *RemoteClient_UnsubscribeAll_Call {
	return &RemoteClient_UnsubscribeAll_Call{Call: _e.mock.On("UnsubscribeAll", ctx, subscriber)}
}

func (_c *RemoteClient_UnsubscribeAll_Call) Run(run func(ctx context.Context, subscriber string)) *RemoteClient_UnsubscribeAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *RemoteClient_UnsubscribeAll_Call) Return(err error) *RemoteClient_UnsubscribeAll_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *RemoteClient_UnsubscribeAll_Call) RunAndReturn(run func(ctx context.Context, subscriber string) error) *RemoteClient_UnsubscribeAll_Call {
	_c.Call.Return(run)
	return _c
}

// Validators provides a mock function for the type RemoteClient
func (_mock *RemoteClient) Validators(ctx context.Context, height *int64, page *int, perPage *int, requestQuorumInfo *bool) (*coretypes.ResultValidators, error) {
	ret := _mock.Called(ctx, height, page, perPage, requestQuorumInfo)

	if len(ret) == 0 {
		panic("no return value specified for Validators")
	}

	var r0 *coretypes.ResultValidators
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64, *int, *int, *bool) (*coretypes.ResultValidators, error)); ok {
		return returnFunc(ctx, height, page, perPage, requestQuorumInfo)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64, *int, *int, *bool) *coretypes.ResultValidators); ok {
		r0 = returnFunc(ctx, height, page, perPage, requestQuorumInfo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultValidators)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64, *int, *int, *bool) error); ok {
		r1 = returnFunc(ctx, height, page, perPage, requestQuorumInfo)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// RemoteClient_Validators_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Validators'
type RemoteClient_Validators_Call struct {
	*mock.Call
}

// Validators is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
//   - page *int
//   - perPage *int
//   - requestQuorumInfo *bool
func (_e *RemoteClient_Expecter) Validators(ctx interface{}, height interface{}, page interface{}, perPage interface{}, requestQuorumInfo interface{}) *RemoteClient_Validators_Call {
	return &RemoteClient_Validators_Call{Call: _e.mock.On("Validators", ctx, height, page, perPage, requestQuorumInfo)}
}

func (_c *RemoteClient_Validators_Call) Run(run func(ctx context.Context, height *int64, page *int, perPage *int, requestQuorumInfo *bool)) *RemoteClient_Validators_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *int64
		if args[1] != nil {
			arg1 = args[1].(*int64)
		}
		var arg2 *int
		if args[2] != nil {
			arg2 = args[2].(*int)
		}
		var arg3 *int
		if args[3] != nil {
			arg3 = args[3].(*int)
		}
		var arg4 *bool
		if args[4] != nil {
			arg4 = args[4].(*bool)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *RemoteClient_Validators_Call) Return(resultValidators *coretypes.ResultValidators, err error) *RemoteClient_Validators_Call {
	_c.Call.Return(resultValidators, err)
	return _c
}

func (_c *RemoteClient_Validators_Call) RunAndReturn(run func(ctx context.Context, height *int64, page *int, perPage *int, requestQuorumInfo *bool) (*coretypes.ResultValidators, error)) *RemoteClient_Validators_Call {
	_c.Call.Return(run)
	return _c
}
