// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/dashpay/tenderdash/libs/bytes"
	"github.com/dashpay/tenderdash/rpc/client"
	"github.com/dashpay/tenderdash/rpc/coretypes"
	"github.com/dashpay/tenderdash/types"
	mock "github.com/stretchr/testify/mock"
)

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// ABCIInfo provides a mock function for the type Client
func (_mock *Client) ABCIInfo(context1 context.Context) (*coretypes.ResultABCIInfo, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ABCIInfo")
	}

	var r0 *coretypes.ResultABCIInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultABCIInfo, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultABCIInfo); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultABCIInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ABCIInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ABCIInfo'
type Client_ABCIInfo_Call struct {
	*mock.Call
}

// ABCIInfo is a helper method to define mock.On call
//   - context1
func (_e *Client_Expecter) ABCIInfo(context1 interface{}) *Client_ABCIInfo_Call {
	return &Client_ABCIInfo_Call{Call: _e.mock.On("ABCIInfo", context1)}
}

func (_c *Client_ABCIInfo_Call) Run(run func(context1 context.Context)) *Client_ABCIInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_ABCIInfo_Call) Return(resultABCIInfo *coretypes.ResultABCIInfo, err error) *Client_ABCIInfo_Call {
	_c.Call.Return(resultABCIInfo, err)
	return _c
}

func (_c *Client_ABCIInfo_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultABCIInfo, error)) *Client_ABCIInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ABCIQuery provides a mock function for the type Client
func (_mock *Client) ABCIQuery(ctx context.Context, path string, data bytes.HexBytes) (*coretypes.ResultABCIQuery, error) {
	ret := _mock.Called(ctx, path, data)

	if len(ret) == 0 {
		panic("no return value specified for ABCIQuery")
	}

	var r0 *coretypes.ResultABCIQuery
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes) (*coretypes.ResultABCIQuery, error)); ok {
		return returnFunc(ctx, path, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes) *coretypes.ResultABCIQuery); ok {
		r0 = returnFunc(ctx, path, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultABCIQuery)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, bytes.HexBytes) error); ok {
		r1 = returnFunc(ctx, path, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ABCIQuery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ABCIQuery'
type Client_ABCIQuery_Call struct {
	*mock.Call
}

// ABCIQuery is a helper method to define mock.On call
//   - ctx
//   - path
//   - data
func (_e *Client_Expecter) ABCIQuery(ctx interface{}, path interface{}, data interface{}) *Client_ABCIQuery_Call {
	return &Client_ABCIQuery_Call{Call: _e.mock.On("ABCIQuery", ctx, path, data)}
}

func (_c *Client_ABCIQuery_Call) Run(run func(ctx context.Context, path string, data bytes.HexBytes)) *Client_ABCIQuery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bytes.HexBytes))
	})
	return _c
}

func (_c *Client_ABCIQuery_Call) Return(resultABCIQuery *coretypes.ResultABCIQuery, err error) *Client_ABCIQuery_Call {
	_c.Call.Return(resultABCIQuery, err)
	return _c
}

func (_c *Client_ABCIQuery_Call) RunAndReturn(run func(ctx context.Context, path string, data bytes.HexBytes) (*coretypes.ResultABCIQuery, error)) *Client_ABCIQuery_Call {
	_c.Call.Return(run)
	return _c
}

// ABCIQueryWithOptions provides a mock function for the type Client
func (_mock *Client) ABCIQueryWithOptions(ctx context.Context, path string, data bytes.HexBytes, opts client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error) {
	ret := _mock.Called(ctx, path, data, opts)

	if len(ret) == 0 {
		panic("no return value specified for ABCIQueryWithOptions")
	}

	var r0 *coretypes.ResultABCIQuery
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes, client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error)); ok {
		return returnFunc(ctx, path, data, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes, client.ABCIQueryOptions) *coretypes.ResultABCIQuery); ok {
		r0 = returnFunc(ctx, path, data, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultABCIQuery)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, bytes.HexBytes, client.ABCIQueryOptions) error); ok {
		r1 = returnFunc(ctx, path, data, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ABCIQueryWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ABCIQueryWithOptions'
type Client_ABCIQueryWithOptions_Call struct {
	*mock.Call
}

// ABCIQueryWithOptions is a helper method to define mock.On call
//   - ctx
//   - path
//   - data
//   - opts
func (_e *Client_Expecter) ABCIQueryWithOptions(ctx interface{}, path interface{}, data interface{}, opts interface{}) *Client_ABCIQueryWithOptions_Call {
	return &Client_ABCIQueryWithOptions_Call{Call: _e.mock.On("ABCIQueryWithOptions", ctx, path, data, opts)}
}

func (_c *Client_ABCIQueryWithOptions_Call) Run(run func(ctx context.Context, path string, data bytes.HexBytes, opts client.ABCIQueryOptions)) *Client_ABCIQueryWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bytes.HexBytes), args[3].(client.ABCIQueryOptions))
	})
	return _c
}

func (_c *Client_ABCIQueryWithOptions_Call) Return(resultABCIQuery *coretypes.ResultABCIQuery, err error) *Client_ABCIQueryWithOptions_Call {
	_c.Call.Return(resultABCIQuery, err)
	return _c
}

func (_c *Client_ABCIQueryWithOptions_Call) RunAndReturn(run func(ctx context.Context, path string, data bytes.HexBytes, opts client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error)) *Client_ABCIQueryWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// Block provides a mock function for the type Client
func (_mock *Client) Block(ctx context.Context, height *int64) (*coretypes.ResultBlock, error) {
	ret := _mock.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for Block")
	}

	var r0 *coretypes.ResultBlock
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultBlock, error)); ok {
		return returnFunc(ctx, height)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultBlock); ok {
		r0 = returnFunc(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlock)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = returnFunc(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Block_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Block'
type Client_Block_Call struct {
	*mock.Call
}

// Block is a helper method to define mock.On call
//   - ctx
//   - height
func (_e *Client_Expecter) Block(ctx interface{}, height interface{}) *Client_Block_Call {
	return &Client_Block_Call{Call: _e.mock.On("Block", ctx, height)}
}

func (_c *Client_Block_Call) Run(run func(ctx context.Context, height *int64)) *Client_Block_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64))
	})
	return _c
}

func (_c *Client_Block_Call) Return(resultBlock *coretypes.ResultBlock, err error) *Client_Block_Call {
	_c.Call.Return(resultBlock, err)
	return _c
}

func (_c *Client_Block_Call) RunAndReturn(run func(ctx context.Context, height *int64) (*coretypes.ResultBlock, error)) *Client_Block_Call {
	_c.Call.Return(run)
	return _c
}

// BlockByHash provides a mock function for the type Client
func (_mock *Client) BlockByHash(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultBlock, error) {
	ret := _mock.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for BlockByHash")
	}

	var r0 *coretypes.ResultBlock
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes) (*coretypes.ResultBlock, error)); ok {
		return returnFunc(ctx, hash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes) *coretypes.ResultBlock); ok {
		r0 = returnFunc(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlock)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, bytes.HexBytes) error); ok {
		r1 = returnFunc(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_BlockByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockByHash'
type Client_BlockByHash_Call struct {
	*mock.Call
}

// BlockByHash is a helper method to define mock.On call
//   - ctx
//   - hash
func (_e *Client_Expecter) BlockByHash(ctx interface{}, hash interface{}) *Client_BlockByHash_Call {
	return &Client_BlockByHash_Call{Call: _e.mock.On("BlockByHash", ctx, hash)}
}

func (_c *Client_BlockByHash_Call) Run(run func(ctx context.Context, hash bytes.HexBytes)) *Client_BlockByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bytes.HexBytes))
	})
	return _c
}

func (_c *Client_BlockByHash_Call) Return(resultBlock *coretypes.ResultBlock, err error) *Client_BlockByHash_Call {
	_c.Call.Return(resultBlock, err)
	return _c
}

func (_c *Client_BlockByHash_Call) RunAndReturn(run func(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultBlock, error)) *Client_BlockByHash_Call {
	_c.Call.Return(run)
	return _c
}

// BlockResults provides a mock function for the type Client
func (_mock *Client) BlockResults(ctx context.Context, height *int64) (*coretypes.ResultBlockResults, error) {
	ret := _mock.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for BlockResults")
	}

	var r0 *coretypes.ResultBlockResults
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultBlockResults, error)); ok {
		return returnFunc(ctx, height)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultBlockResults); ok {
		r0 = returnFunc(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlockResults)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = returnFunc(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_BlockResults_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockResults'
type Client_BlockResults_Call struct {
	*mock.Call
}

// BlockResults is a helper method to define mock.On call
//   - ctx
//   - height
func (_e *Client_Expecter) BlockResults(ctx interface{}, height interface{}) *Client_BlockResults_Call {
	return &Client_BlockResults_Call{Call: _e.mock.On("BlockResults", ctx, height)}
}

func (_c *Client_BlockResults_Call) Run(run func(ctx context.Context, height *int64)) *Client_BlockResults_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64))
	})
	return _c
}

func (_c *Client_BlockResults_Call) Return(resultBlockResults *coretypes.ResultBlockResults, err error) *Client_BlockResults_Call {
	_c.Call.Return(resultBlockResults, err)
	return _c
}

func (_c *Client_BlockResults_Call) RunAndReturn(run func(ctx context.Context, height *int64) (*coretypes.ResultBlockResults, error)) *Client_BlockResults_Call {
	_c.Call.Return(run)
	return _c
}

// BlockSearch provides a mock function for the type Client
func (_mock *Client) BlockSearch(ctx context.Context, query string, page *int, perPage *int, orderBy string) (*coretypes.ResultBlockSearch, error) {
	ret := _mock.Called(ctx, query, page, perPage, orderBy)

	if len(ret) == 0 {
		panic("no return value specified for BlockSearch")
	}

	var r0 *coretypes.ResultBlockSearch
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *int, *int, string) (*coretypes.ResultBlockSearch, error)); ok {
		return returnFunc(ctx, query, page, perPage, orderBy)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *int, *int, string) *coretypes.ResultBlockSearch); ok {
		r0 = returnFunc(ctx, query, page, perPage, orderBy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlockSearch)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, *int, *int, string) error); ok {
		r1 = returnFunc(ctx, query, page, perPage, orderBy)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_BlockSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockSearch'
type Client_BlockSearch_Call struct {
	*mock.Call
}

// BlockSearch is a helper method to define mock.On call
//   - ctx
//   - query
//   - page
//   - perPage
//   - orderBy
func (_e *Client_Expecter) BlockSearch(ctx interface{}, query interface{}, page interface{}, perPage interface{}, orderBy interface{}) *Client_BlockSearch_Call {
	return &Client_BlockSearch_Call{Call: _e.mock.On("BlockSearch", ctx, query, page, perPage, orderBy)}
}

func (_c *Client_BlockSearch_Call) Run(run func(ctx context.Context, query string, page *int, perPage *int, orderBy string)) *Client_BlockSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*int), args[3].(*int), args[4].(string))
	})
	return _c
}

func (_c *Client_BlockSearch_Call) Return(resultBlockSearch *coretypes.ResultBlockSearch, err error) *Client_BlockSearch_Call {
	_c.Call.Return(resultBlockSearch, err)
	return _c
}

func (_c *Client_BlockSearch_Call) RunAndReturn(run func(ctx context.Context, query string, page *int, perPage *int, orderBy string) (*coretypes.ResultBlockSearch, error)) *Client_BlockSearch_Call {
	_c.Call.Return(run)
	return _c
}

// BlockchainInfo provides a mock function for the type Client
func (_mock *Client) BlockchainInfo(ctx context.Context, minHeight int64, maxHeight int64) (*coretypes.ResultBlockchainInfo, error) {
	ret := _mock.Called(ctx, minHeight, maxHeight)

	if len(ret) == 0 {
		panic("no return value specified for BlockchainInfo")
	}

	var r0 *coretypes.ResultBlockchainInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int64) (*coretypes.ResultBlockchainInfo, error)); ok {
		return returnFunc(ctx, minHeight, maxHeight)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int64) *coretypes.ResultBlockchainInfo); ok {
		r0 = returnFunc(ctx, minHeight, maxHeight)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlockchainInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = returnFunc(ctx, minHeight, maxHeight)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_BlockchainInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockchainInfo'
type Client_BlockchainInfo_Call struct {
	*mock.Call
}

// BlockchainInfo is a helper method to define mock.On call
//   - ctx
//   - minHeight
//   - maxHeight
func (_e *Client_Expecter) BlockchainInfo(ctx interface{}, minHeight interface{}, maxHeight interface{}) *Client_BlockchainInfo_Call {
	return &Client_BlockchainInfo_Call{Call: _e.mock.On("BlockchainInfo", ctx, minHeight, maxHeight)}
}

func (_c *Client_BlockchainInfo_Call) Run(run func(ctx context.Context, minHeight int64, maxHeight int64)) *Client_BlockchainInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *Client_BlockchainInfo_Call) Return(resultBlockchainInfo *coretypes.ResultBlockchainInfo, err error) *Client_BlockchainInfo_Call {
	_c.Call.Return(resultBlockchainInfo, err)
	return _c
}

func (_c *Client_BlockchainInfo_Call) RunAndReturn(run func(ctx context.Context, minHeight int64, maxHeight int64) (*coretypes.ResultBlockchainInfo, error)) *Client_BlockchainInfo_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastEvidence provides a mock function for the type Client
func (_mock *Client) BroadcastEvidence(context1 context.Context, evidence types.Evidence) (*coretypes.ResultBroadcastEvidence, error) {
	ret := _mock.Called(context1, evidence)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastEvidence")
	}

	var r0 *coretypes.ResultBroadcastEvidence
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Evidence) (*coretypes.ResultBroadcastEvidence, error)); ok {
		return returnFunc(context1, evidence)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Evidence) *coretypes.ResultBroadcastEvidence); ok {
		r0 = returnFunc(context1, evidence)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastEvidence)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Evidence) error); ok {
		r1 = returnFunc(context1, evidence)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_BroadcastEvidence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastEvidence'
type Client_BroadcastEvidence_Call struct {
	*mock.Call
}

// BroadcastEvidence is a helper method to define mock.On call
//   - context1
//   - evidence
func (_e *Client_Expecter) BroadcastEvidence(context1 interface{}, evidence interface{}) *Client_BroadcastEvidence_Call {
	return &Client_BroadcastEvidence_Call{Call: _e.mock.On("BroadcastEvidence", context1, evidence)}
}

func (_c *Client_BroadcastEvidence_Call) Run(run func(context1 context.Context, evidence types.Evidence)) *Client_BroadcastEvidence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Evidence))
	})
	return _c
}

func (_c *Client_BroadcastEvidence_Call) Return(resultBroadcastEvidence *coretypes.ResultBroadcastEvidence, err error) *Client_BroadcastEvidence_Call {
	_c.Call.Return(resultBroadcastEvidence, err)
	return _c
}

func (_c *Client_BroadcastEvidence_Call) RunAndReturn(run func(context1 context.Context, evidence types.Evidence) (*coretypes.ResultBroadcastEvidence, error)) *Client_BroadcastEvidence_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastTx provides a mock function for the type Client
func (_mock *Client) BroadcastTx(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error) {
	ret := _mock.Called(context1, tx)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastTx")
	}

	var r0 *coretypes.ResultBroadcastTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultBroadcastTx, error)); ok {
		return returnFunc(context1, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultBroadcastTx); ok {
		r0 = returnFunc(context1, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = returnFunc(context1, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_BroadcastTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastTx'
type Client_BroadcastTx_Call struct {
	*mock.Call
}

// BroadcastTx is a helper method to define mock.On call
//   - context1
//   - tx
func (_e *Client_Expecter) BroadcastTx(context1 interface{}, tx interface{}) *Client_BroadcastTx_Call {
	return &Client_BroadcastTx_Call{Call: _e.mock.On("BroadcastTx", context1, tx)}
}

func (_c *Client_BroadcastTx_Call) Run(run func(context1 context.Context, tx types.Tx)) *Client_BroadcastTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Tx))
	})
	return _c
}

func (_c *Client_BroadcastTx_Call) Return(resultBroadcastTx *coretypes.ResultBroadcastTx, err error) *Client_BroadcastTx_Call {
	_c.Call.Return(resultBroadcastTx, err)
	return _c
}

func (_c *Client_BroadcastTx_Call) RunAndReturn(run func(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error)) *Client_BroadcastTx_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastTxAsync provides a mock function for the type Client
func (_mock *Client) BroadcastTxAsync(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error) {
	ret := _mock.Called(context1, tx)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastTxAsync")
	}

	var r0 *coretypes.ResultBroadcastTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultBroadcastTx, error)); ok {
		return returnFunc(context1, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultBroadcastTx); ok {
		r0 = returnFunc(context1, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = returnFunc(context1, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_BroadcastTxAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastTxAsync'
type Client_BroadcastTxAsync_Call struct {
	*mock.Call
}

// BroadcastTxAsync is a helper method to define mock.On call
//   - context1
//   - tx
func (_e *Client_Expecter) BroadcastTxAsync(context1 interface{}, tx interface{}) *Client_BroadcastTxAsync_Call {
	return &Client_BroadcastTxAsync_Call{Call: _e.mock.On("BroadcastTxAsync", context1, tx)}
}

func (_c *Client_BroadcastTxAsync_Call) Run(run func(context1 context.Context, tx types.Tx)) *Client_BroadcastTxAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Tx))
	})
	return _c
}

func (_c *Client_BroadcastTxAsync_Call) Return(resultBroadcastTx *coretypes.ResultBroadcastTx, err error) *Client_BroadcastTxAsync_Call {
	_c.Call.Return(resultBroadcastTx, err)
	return _c
}

func (_c *Client_BroadcastTxAsync_Call) RunAndReturn(run func(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error)) *Client_BroadcastTxAsync_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastTxCommit provides a mock function for the type Client
func (_mock *Client) BroadcastTxCommit(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTxCommit, error) {
	ret := _mock.Called(context1, tx)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastTxCommit")
	}

	var r0 *coretypes.ResultBroadcastTxCommit
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultBroadcastTxCommit, error)); ok {
		return returnFunc(context1, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultBroadcastTxCommit); ok {
		r0 = returnFunc(context1, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastTxCommit)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = returnFunc(context1, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_BroadcastTxCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastTxCommit'
type Client_BroadcastTxCommit_Call struct {
	*mock.Call
}

// BroadcastTxCommit is a helper method to define mock.On call
//   - context1
//   - tx
func (_e *Client_Expecter) BroadcastTxCommit(context1 interface{}, tx interface{}) *Client_BroadcastTxCommit_Call {
	return &Client_BroadcastTxCommit_Call{Call: _e.mock.On("BroadcastTxCommit", context1, tx)}
}

func (_c *Client_BroadcastTxCommit_Call) Run(run func(context1 context.Context, tx types.Tx)) *Client_BroadcastTxCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Tx))
	})
	return _c
}

func (_c *Client_BroadcastTxCommit_Call) Return(resultBroadcastTxCommit *coretypes.ResultBroadcastTxCommit, err error) *Client_BroadcastTxCommit_Call {
	_c.Call.Return(resultBroadcastTxCommit, err)
	return _c
}

func (_c *Client_BroadcastTxCommit_Call) RunAndReturn(run func(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTxCommit, error)) *Client_BroadcastTxCommit_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastTxSync provides a mock function for the type Client
func (_mock *Client) BroadcastTxSync(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error) {
	ret := _mock.Called(context1, tx)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastTxSync")
	}

	var r0 *coretypes.ResultBroadcastTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultBroadcastTx, error)); ok {
		return returnFunc(context1, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultBroadcastTx); ok {
		r0 = returnFunc(context1, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = returnFunc(context1, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_BroadcastTxSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastTxSync'
type Client_BroadcastTxSync_Call struct {
	*mock.Call
}

// BroadcastTxSync is a helper method to define mock.On call
//   - context1
//   - tx
func (_e *Client_Expecter) BroadcastTxSync(context1 interface{}, tx interface{}) *Client_BroadcastTxSync_Call {
	return &Client_BroadcastTxSync_Call{Call: _e.mock.On("BroadcastTxSync", context1, tx)}
}

func (_c *Client_BroadcastTxSync_Call) Run(run func(context1 context.Context, tx types.Tx)) *Client_BroadcastTxSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Tx))
	})
	return _c
}

func (_c *Client_BroadcastTxSync_Call) Return(resultBroadcastTx *coretypes.ResultBroadcastTx, err error) *Client_BroadcastTxSync_Call {
	_c.Call.Return(resultBroadcastTx, err)
	return _c
}

func (_c *Client_BroadcastTxSync_Call) RunAndReturn(run func(context1 context.Context, tx types.Tx) (*coretypes.ResultBroadcastTx, error)) *Client_BroadcastTxSync_Call {
	_c.Call.Return(run)
	return _c
}

// CheckTx provides a mock function for the type Client
func (_mock *Client) CheckTx(context1 context.Context, tx types.Tx) (*coretypes.ResultCheckTx, error) {
	ret := _mock.Called(context1, tx)

	if len(ret) == 0 {
		panic("no return value specified for CheckTx")
	}

	var r0 *coretypes.ResultCheckTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultCheckTx, error)); ok {
		return returnFunc(context1, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultCheckTx); ok {
		r0 = returnFunc(context1, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultCheckTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = returnFunc(context1, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CheckTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckTx'
type Client_CheckTx_Call struct {
	*mock.Call
}

// CheckTx is a helper method to define mock.On call
//   - context1
//   - tx
func (_e *Client_Expecter) CheckTx(context1 interface{}, tx interface{}) *Client_CheckTx_Call {
	return &Client_CheckTx_Call{Call: _e.mock.On("CheckTx", context1, tx)}
}

func (_c *Client_CheckTx_Call) Run(run func(context1 context.Context, tx types.Tx)) *Client_CheckTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Tx))
	})
	return _c
}

func (_c *Client_CheckTx_Call) Return(resultCheckTx *coretypes.ResultCheckTx, err error) *Client_CheckTx_Call {
	_c.Call.Return(resultCheckTx, err)
	return _c
}

func (_c *Client_CheckTx_Call) RunAndReturn(run func(context1 context.Context, tx types.Tx) (*coretypes.ResultCheckTx, error)) *Client_CheckTx_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function for the type Client
func (_mock *Client) Commit(ctx context.Context, height *int64) (*coretypes.ResultCommit, error) {
	ret := _mock.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 *coretypes.ResultCommit
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultCommit, error)); ok {
		return returnFunc(ctx, height)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultCommit); ok {
		r0 = returnFunc(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultCommit)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = returnFunc(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type Client_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
//   - ctx
//   - height
func (_e *Client_Expecter) Commit(ctx interface{}, height interface{}) *Client_Commit_Call {
	return &Client_Commit_Call{Call: _e.mock.On("Commit", ctx, height)}
}

func (_c *Client_Commit_Call) Run(run func(ctx context.Context, height *int64)) *Client_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64))
	})
	return _c
}

func (_c *Client_Commit_Call) Return(resultCommit *coretypes.ResultCommit, err error) *Client_Commit_Call {
	_c.Call.Return(resultCommit, err)
	return _c
}

func (_c *Client_Commit_Call) RunAndReturn(run func(ctx context.Context, height *int64) (*coretypes.ResultCommit, error)) *Client_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// ConsensusParams provides a mock function for the type Client
func (_mock *Client) ConsensusParams(ctx context.Context, height *int64) (*coretypes.ResultConsensusParams, error) {
	ret := _mock.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for ConsensusParams")
	}

	var r0 *coretypes.ResultConsensusParams
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultConsensusParams, error)); ok {
		return returnFunc(ctx, height)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultConsensusParams); ok {
		r0 = returnFunc(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultConsensusParams)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = returnFunc(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ConsensusParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsensusParams'
type Client_ConsensusParams_Call struct {
	*mock.Call
}

// ConsensusParams is a helper method to define mock.On call
//   - ctx
//   - height
func (_e *Client_Expecter) ConsensusParams(ctx interface{}, height interface{}) *Client_ConsensusParams_Call {
	return &Client_ConsensusParams_Call{Call: _e.mock.On("ConsensusParams", ctx, height)}
}

func (_c *Client_ConsensusParams_Call) Run(run func(ctx context.Context, height *int64)) *Client_ConsensusParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64))
	})
	return _c
}

func (_c *Client_ConsensusParams_Call) Return(resultConsensusParams *coretypes.ResultConsensusParams, err error) *Client_ConsensusParams_Call {
	_c.Call.Return(resultConsensusParams, err)
	return _c
}

func (_c *Client_ConsensusParams_Call) RunAndReturn(run func(ctx context.Context, height *int64) (*coretypes.ResultConsensusParams, error)) *Client_ConsensusParams_Call {
	_c.Call.Return(run)
	return _c
}

// ConsensusState provides a mock function for the type Client
func (_mock *Client) ConsensusState(context1 context.Context) (*coretypes.ResultConsensusState, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ConsensusState")
	}

	var r0 *coretypes.ResultConsensusState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultConsensusState, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultConsensusState); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultConsensusState)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_ConsensusState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsensusState'
type Client_ConsensusState_Call struct {
	*mock.Call
}

// ConsensusState is a helper method to define mock.On call
//   - context1
func (_e *Client_Expecter) ConsensusState(context1 interface{}) *Client_ConsensusState_Call {
	return &Client_ConsensusState_Call{Call: _e.mock.On("ConsensusState", context1)}
}

func (_c *Client_ConsensusState_Call) Run(run func(context1 context.Context)) *Client_ConsensusState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_ConsensusState_Call) Return(resultConsensusState *coretypes.ResultConsensusState, err error) *Client_ConsensusState_Call {
	_c.Call.Return(resultConsensusState, err)
	return _c
}

func (_c *Client_ConsensusState_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultConsensusState, error)) *Client_ConsensusState_Call {
	_c.Call.Return(run)
	return _c
}

// DumpConsensusState provides a mock function for the type Client
func (_mock *Client) DumpConsensusState(context1 context.Context) (*coretypes.ResultDumpConsensusState, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for DumpConsensusState")
	}

	var r0 *coretypes.ResultDumpConsensusState
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultDumpConsensusState, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultDumpConsensusState); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultDumpConsensusState)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_DumpConsensusState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DumpConsensusState'
type Client_DumpConsensusState_Call struct {
	*mock.Call
}

// DumpConsensusState is a helper method to define mock.On call
//   - context1
func (_e *Client_Expecter) DumpConsensusState(context1 interface{}) *Client_DumpConsensusState_Call {
	return &Client_DumpConsensusState_Call{Call: _e.mock.On("DumpConsensusState", context1)}
}

func (_c *Client_DumpConsensusState_Call) Run(run func(context1 context.Context)) *Client_DumpConsensusState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_DumpConsensusState_Call) Return(resultDumpConsensusState *coretypes.ResultDumpConsensusState, err error) *Client_DumpConsensusState_Call {
	_c.Call.Return(resultDumpConsensusState, err)
	return _c
}

func (_c *Client_DumpConsensusState_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultDumpConsensusState, error)) *Client_DumpConsensusState_Call {
	_c.Call.Return(run)
	return _c
}

// Events provides a mock function for the type Client
func (_mock *Client) Events(ctx context.Context, req *coretypes.RequestEvents) (*coretypes.ResultEvents, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Events")
	}

	var r0 *coretypes.ResultEvents
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *coretypes.RequestEvents) (*coretypes.ResultEvents, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *coretypes.RequestEvents) *coretypes.ResultEvents); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultEvents)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *coretypes.RequestEvents) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Events_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Events'
type Client_Events_Call struct {
	*mock.Call
}

// Events is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *Client_Expecter) Events(ctx interface{}, req interface{}) *Client_Events_Call {
	return &Client_Events_Call{Call: _e.mock.On("Events", ctx, req)}
}

func (_c *Client_Events_Call) Run(run func(ctx context.Context, req *coretypes.RequestEvents)) *Client_Events_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*coretypes.RequestEvents))
	})
	return _c
}

func (_c *Client_Events_Call) Return(resultEvents *coretypes.ResultEvents, err error) *Client_Events_Call {
	_c.Call.Return(resultEvents, err)
	return _c
}

func (_c *Client_Events_Call) RunAndReturn(run func(ctx context.Context, req *coretypes.RequestEvents) (*coretypes.ResultEvents, error)) *Client_Events_Call {
	_c.Call.Return(run)
	return _c
}

// Genesis provides a mock function for the type Client
func (_mock *Client) Genesis(context1 context.Context) (*coretypes.ResultGenesis, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Genesis")
	}

	var r0 *coretypes.ResultGenesis
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultGenesis, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultGenesis); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultGenesis)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Genesis_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Genesis'
type Client_Genesis_Call struct {
	*mock.Call
}

// Genesis is a helper method to define mock.On call
//   - context1
func (_e *Client_Expecter) Genesis(context1 interface{}) *Client_Genesis_Call {
	return &Client_Genesis_Call{Call: _e.mock.On("Genesis", context1)}
}

func (_c *Client_Genesis_Call) Run(run func(context1 context.Context)) *Client_Genesis_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_Genesis_Call) Return(resultGenesis *coretypes.ResultGenesis, err error) *Client_Genesis_Call {
	_c.Call.Return(resultGenesis, err)
	return _c
}

func (_c *Client_Genesis_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultGenesis, error)) *Client_Genesis_Call {
	_c.Call.Return(run)
	return _c
}

// GenesisChunked provides a mock function for the type Client
func (_mock *Client) GenesisChunked(context1 context.Context, v uint) (*coretypes.ResultGenesisChunk, error) {
	ret := _mock.Called(context1, v)

	if len(ret) == 0 {
		panic("no return value specified for GenesisChunked")
	}

	var r0 *coretypes.ResultGenesisChunk
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) (*coretypes.ResultGenesisChunk, error)); ok {
		return returnFunc(context1, v)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) *coretypes.ResultGenesisChunk); ok {
		r0 = returnFunc(context1, v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultGenesisChunk)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = returnFunc(context1, v)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_GenesisChunked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenesisChunked'
type Client_GenesisChunked_Call struct {
	*mock.Call
}

// GenesisChunked is a helper method to define mock.On call
//   - context1
//   - v
func (_e *Client_Expecter) GenesisChunked(context1 interface{}, v interface{}) *Client_GenesisChunked_Call {
	return &Client_GenesisChunked_Call{Call: _e.mock.On("GenesisChunked", context1, v)}
}

func (_c *Client_GenesisChunked_Call) Run(run func(context1 context.Context, v uint)) *Client_GenesisChunked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *Client_GenesisChunked_Call) Return(resultGenesisChunk *coretypes.ResultGenesisChunk, err error) *Client_GenesisChunked_Call {
	_c.Call.Return(resultGenesisChunk, err)
	return _c
}

func (_c *Client_GenesisChunked_Call) RunAndReturn(run func(context1 context.Context, v uint) (*coretypes.ResultGenesisChunk, error)) *Client_GenesisChunked_Call {
	_c.Call.Return(run)
	return _c
}

// Header provides a mock function for the type Client
func (_mock *Client) Header(ctx context.Context, height *int64) (*coretypes.ResultHeader, error) {
	ret := _mock.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for Header")
	}

	var r0 *coretypes.ResultHeader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultHeader, error)); ok {
		return returnFunc(ctx, height)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultHeader); ok {
		r0 = returnFunc(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultHeader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = returnFunc(ctx, height)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Header_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Header'
type Client_Header_Call struct {
	*mock.Call
}

// Header is a helper method to define mock.On call
//   - ctx
//   - height
func (_e *Client_Expecter) Header(ctx interface{}, height interface{}) *Client_Header_Call {
	return &Client_Header_Call{Call: _e.mock.On("Header", ctx, height)}
}

func (_c *Client_Header_Call) Run(run func(ctx context.Context, height *int64)) *Client_Header_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64))
	})
	return _c
}

func (_c *Client_Header_Call) Return(resultHeader *coretypes.ResultHeader, err error) *Client_Header_Call {
	_c.Call.Return(resultHeader, err)
	return _c
}

func (_c *Client_Header_Call) RunAndReturn(run func(ctx context.Context, height *int64) (*coretypes.ResultHeader, error)) *Client_Header_Call {
	_c.Call.Return(run)
	return _c
}

// HeaderByHash provides a mock function for the type Client
func (_mock *Client) HeaderByHash(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultHeader, error) {
	ret := _mock.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for HeaderByHash")
	}

	var r0 *coretypes.ResultHeader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes) (*coretypes.ResultHeader, error)); ok {
		return returnFunc(ctx, hash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes) *coretypes.ResultHeader); ok {
		r0 = returnFunc(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultHeader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, bytes.HexBytes) error); ok {
		r1 = returnFunc(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_HeaderByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HeaderByHash'
type Client_HeaderByHash_Call struct {
	*mock.Call
}

// HeaderByHash is a helper method to define mock.On call
//   - ctx
//   - hash
func (_e *Client_Expecter) HeaderByHash(ctx interface{}, hash interface{}) *Client_HeaderByHash_Call {
	return &Client_HeaderByHash_Call{Call: _e.mock.On("HeaderByHash", ctx, hash)}
}

func (_c *Client_HeaderByHash_Call) Run(run func(ctx context.Context, hash bytes.HexBytes)) *Client_HeaderByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bytes.HexBytes))
	})
	return _c
}

func (_c *Client_HeaderByHash_Call) Return(resultHeader *coretypes.ResultHeader, err error) *Client_HeaderByHash_Call {
	_c.Call.Return(resultHeader, err)
	return _c
}

func (_c *Client_HeaderByHash_Call) RunAndReturn(run func(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultHeader, error)) *Client_HeaderByHash_Call {
	_c.Call.Return(run)
	return _c
}

// Health provides a mock function for the type Client
func (_mock *Client) Health(context1 context.Context) (*coretypes.ResultHealth, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Health")
	}

	var r0 *coretypes.ResultHealth
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultHealth, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultHealth); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultHealth)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Health_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Health'
type Client_Health_Call struct {
	*mock.Call
}

// Health is a helper method to define mock.On call
//   - context1
func (_e *Client_Expecter) Health(context1 interface{}) *Client_Health_Call {
	return &Client_Health_Call{Call: _e.mock.On("Health", context1)}
}

func (_c *Client_Health_Call) Run(run func(context1 context.Context)) *Client_Health_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_Health_Call) Return(resultHealth *coretypes.ResultHealth, err error) *Client_Health_Call {
	_c.Call.Return(resultHealth, err)
	return _c
}

func (_c *Client_Health_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultHealth, error)) *Client_Health_Call {
	_c.Call.Return(run)
	return _c
}

// NetInfo provides a mock function for the type Client
func (_mock *Client) NetInfo(context1 context.Context) (*coretypes.ResultNetInfo, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for NetInfo")
	}

	var r0 *coretypes.ResultNetInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultNetInfo, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultNetInfo); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultNetInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_NetInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetInfo'
type Client_NetInfo_Call struct {
	*mock.Call
}

// NetInfo is a helper method to define mock.On call
//   - context1
func (_e *Client_Expecter) NetInfo(context1 interface{}) *Client_NetInfo_Call {
	return &Client_NetInfo_Call{Call: _e.mock.On("NetInfo", context1)}
}

func (_c *Client_NetInfo_Call) Run(run func(context1 context.Context)) *Client_NetInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_NetInfo_Call) Return(resultNetInfo *coretypes.ResultNetInfo, err error) *Client_NetInfo_Call {
	_c.Call.Return(resultNetInfo, err)
	return _c
}

func (_c *Client_NetInfo_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultNetInfo, error)) *Client_NetInfo_Call {
	_c.Call.Return(run)
	return _c
}

// NumUnconfirmedTxs provides a mock function for the type Client
func (_mock *Client) NumUnconfirmedTxs(context1 context.Context) (*coretypes.ResultUnconfirmedTxs, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for NumUnconfirmedTxs")
	}

	var r0 *coretypes.ResultUnconfirmedTxs
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultUnconfirmedTxs, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultUnconfirmedTxs); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultUnconfirmedTxs)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_NumUnconfirmedTxs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NumUnconfirmedTxs'
type Client_NumUnconfirmedTxs_Call struct {
	*mock.Call
}

// NumUnconfirmedTxs is a helper method to define mock.On call
//   - context1
func (_e *Client_Expecter) NumUnconfirmedTxs(context1 interface{}) *Client_NumUnconfirmedTxs_Call {
	return &Client_NumUnconfirmedTxs_Call{Call: _e.mock.On("NumUnconfirmedTxs", context1)}
}

func (_c *Client_NumUnconfirmedTxs_Call) Run(run func(context1 context.Context)) *Client_NumUnconfirmedTxs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_NumUnconfirmedTxs_Call) Return(resultUnconfirmedTxs *coretypes.ResultUnconfirmedTxs, err error) *Client_NumUnconfirmedTxs_Call {
	_c.Call.Return(resultUnconfirmedTxs, err)
	return _c
}

func (_c *Client_NumUnconfirmedTxs_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultUnconfirmedTxs, error)) *Client_NumUnconfirmedTxs_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveTx provides a mock function for the type Client
func (_mock *Client) RemoveTx(context1 context.Context, txKey types.TxKey) error {
	ret := _mock.Called(context1, txKey)

	if len(ret) == 0 {
		panic("no return value specified for RemoveTx")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TxKey) error); ok {
		r0 = returnFunc(context1, txKey)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_RemoveTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveTx'
type Client_RemoveTx_Call struct {
	*mock.Call
}

// RemoveTx is a helper method to define mock.On call
//   - context1
//   - txKey
func (_e *Client_Expecter) RemoveTx(context1 interface{}, txKey interface{}) *Client_RemoveTx_Call {
	return &Client_RemoveTx_Call{Call: _e.mock.On("RemoveTx", context1, txKey)}
}

func (_c *Client_RemoveTx_Call) Run(run func(context1 context.Context, txKey types.TxKey)) *Client_RemoveTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.TxKey))
	})
	return _c
}

func (_c *Client_RemoveTx_Call) Return(err error) *Client_RemoveTx_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_RemoveTx_Call) RunAndReturn(run func(context1 context.Context, txKey types.TxKey) error) *Client_RemoveTx_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type Client
func (_mock *Client) Start(context1 context.Context) error {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type Client_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - context1
func (_e *Client_Expecter) Start(context1 interface{}) *Client_Start_Call {
	return &Client_Start_Call{Call: _e.mock.On("Start", context1)}
}

func (_c *Client_Start_Call) Run(run func(context1 context.Context)) *Client_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_Start_Call) Return(err error) *Client_Start_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_Start_Call) RunAndReturn(run func(context1 context.Context) error) *Client_Start_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function for the type Client
func (_mock *Client) Status(context1 context.Context) (*coretypes.ResultStatus, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 *coretypes.ResultStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultStatus, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *coretypes.ResultStatus); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type Client_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - context1
func (_e *Client_Expecter) Status(context1 interface{}) *Client_Status_Call {
	return &Client_Status_Call{Call: _e.mock.On("Status", context1)}
}

func (_c *Client_Status_Call) Run(run func(context1 context.Context)) *Client_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Client_Status_Call) Return(resultStatus *coretypes.ResultStatus, err error) *Client_Status_Call {
	_c.Call.Return(resultStatus, err)
	return _c
}

func (_c *Client_Status_Call) RunAndReturn(run func(context1 context.Context) (*coretypes.ResultStatus, error)) *Client_Status_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function for the type Client
func (_mock *Client) Subscribe(ctx context.Context, subscriber string, query string, outCapacity ...int) (<-chan coretypes.ResultEvent, error) {
	var tmpRet mock.Arguments
	if len(outCapacity) > 0 {
		tmpRet = _mock.Called(ctx, subscriber, query, outCapacity)
	} else {
		tmpRet = _mock.Called(ctx, subscriber, query)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 <-chan coretypes.ResultEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, ...int) (<-chan coretypes.ResultEvent, error)); ok {
		return returnFunc(ctx, subscriber, query, outCapacity...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, ...int) <-chan coretypes.ResultEvent); ok {
		r0 = returnFunc(ctx, subscriber, query, outCapacity...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan coretypes.ResultEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, ...int) error); ok {
		r1 = returnFunc(ctx, subscriber, query, outCapacity...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type Client_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - ctx
//   - subscriber
//   - query
//   - outCapacity
func (_e *Client_Expecter) Subscribe(ctx interface{}, subscriber interface{}, query interface{}, outCapacity ...interface{}) *Client_Subscribe_Call {
	return &Client_Subscribe_Call{Call: _e.mock.On("Subscribe",
		append([]interface{}{ctx, subscriber, query}, outCapacity...)...)}
}

func (_c *Client_Subscribe_Call) Run(run func(ctx context.Context, subscriber string, query string, outCapacity ...int)) *Client_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := args[3].([]int)
		run(args[0].(context.Context), args[1].(string), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *Client_Subscribe_Call) Return(out <-chan coretypes.ResultEvent, err error) *Client_Subscribe_Call {
	_c.Call.Return(out, err)
	return _c
}

func (_c *Client_Subscribe_Call) RunAndReturn(run func(ctx context.Context, subscriber string, query string, outCapacity ...int) (<-chan coretypes.ResultEvent, error)) *Client_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// Tx provides a mock function for the type Client
func (_mock *Client) Tx(ctx context.Context, hash bytes.HexBytes, prove bool) (*coretypes.ResultTx, error) {
	ret := _mock.Called(ctx, hash, prove)

	if len(ret) == 0 {
		panic("no return value specified for Tx")
	}

	var r0 *coretypes.ResultTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes, bool) (*coretypes.ResultTx, error)); ok {
		return returnFunc(ctx, hash, prove)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, bytes.HexBytes, bool) *coretypes.ResultTx); ok {
		r0 = returnFunc(ctx, hash, prove)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, bytes.HexBytes, bool) error); ok {
		r1 = returnFunc(ctx, hash, prove)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Tx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Tx'
type Client_Tx_Call struct {
	*mock.Call
}

// Tx is a helper method to define mock.On call
//   - ctx
//   - hash
//   - prove
func (_e *Client_Expecter) Tx(ctx interface{}, hash interface{}, prove interface{}) *Client_Tx_Call {
	return &Client_Tx_Call{Call: _e.mock.On("Tx", ctx, hash, prove)}
}

func (_c *Client_Tx_Call) Run(run func(ctx context.Context, hash bytes.HexBytes, prove bool)) *Client_Tx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bytes.HexBytes), args[2].(bool))
	})
	return _c
}

func (_c *Client_Tx_Call) Return(resultTx *coretypes.ResultTx, err error) *Client_Tx_Call {
	_c.Call.Return(resultTx, err)
	return _c
}

func (_c *Client_Tx_Call) RunAndReturn(run func(ctx context.Context, hash bytes.HexBytes, prove bool) (*coretypes.ResultTx, error)) *Client_Tx_Call {
	_c.Call.Return(run)
	return _c
}

// TxSearch provides a mock function for the type Client
func (_mock *Client) TxSearch(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string) (*coretypes.ResultTxSearch, error) {
	ret := _mock.Called(ctx, query, prove, page, perPage, orderBy)

	if len(ret) == 0 {
		panic("no return value specified for TxSearch")
	}

	var r0 *coretypes.ResultTxSearch
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool, *int, *int, string) (*coretypes.ResultTxSearch, error)); ok {
		return returnFunc(ctx, query, prove, page, perPage, orderBy)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool, *int, *int, string) *coretypes.ResultTxSearch); ok {
		r0 = returnFunc(ctx, query, prove, page, perPage, orderBy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultTxSearch)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, bool, *int, *int, string) error); ok {
		r1 = returnFunc(ctx, query, prove, page, perPage, orderBy)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_TxSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxSearch'
type Client_TxSearch_Call struct {
	*mock.Call
}

// TxSearch is a helper method to define mock.On call
//   - ctx
//   - query
//   - prove
//   - page
//   - perPage
//   - orderBy
func (_e *Client_Expecter) TxSearch(ctx interface{}, query interface{}, prove interface{}, page interface{}, perPage interface{}, orderBy interface{}) *Client_TxSearch_Call {
	return &Client_TxSearch_Call{Call: _e.mock.On("TxSearch", ctx, query, prove, page, perPage, orderBy)}
}

func (_c *Client_TxSearch_Call) Run(run func(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string)) *Client_TxSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool), args[3].(*int), args[4].(*int), args[5].(string))
	})
	return _c
}

func (_c *Client_TxSearch_Call) Return(resultTxSearch *coretypes.ResultTxSearch, err error) *Client_TxSearch_Call {
	_c.Call.Return(resultTxSearch, err)
	return _c
}

func (_c *Client_TxSearch_Call) RunAndReturn(run func(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string) (*coretypes.ResultTxSearch, error)) *Client_TxSearch_Call {
	_c.Call.Return(run)
	return _c
}

// UnconfirmedTx provides a mock function for the type Client
func (_mock *Client) UnconfirmedTx(ctx context.Context, txHash []byte) (*coretypes.ResultUnconfirmedTx, error) {
	ret := _mock.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for UnconfirmedTx")
	}

	var r0 *coretypes.ResultUnconfirmedTx
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []byte) (*coretypes.ResultUnconfirmedTx, error)); ok {
		return returnFunc(ctx, txHash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []byte) *coretypes.ResultUnconfirmedTx); ok {
		r0 = returnFunc(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultUnconfirmedTx)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []byte) error); ok {
		r1 = returnFunc(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_UnconfirmedTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnconfirmedTx'
type Client_UnconfirmedTx_Call struct {
	*mock.Call
}

// UnconfirmedTx is a helper method to define mock.On call
//   - ctx
//   - txHash
func (_e *Client_Expecter) UnconfirmedTx(ctx interface{}, txHash interface{}) *Client_UnconfirmedTx_Call {
	return &Client_UnconfirmedTx_Call{Call: _e.mock.On("UnconfirmedTx", ctx, txHash)}
}

func (_c *Client_UnconfirmedTx_Call) Run(run func(ctx context.Context, txHash []byte)) *Client_UnconfirmedTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]byte))
	})
	return _c
}

func (_c *Client_UnconfirmedTx_Call) Return(resultUnconfirmedTx *coretypes.ResultUnconfirmedTx, err error) *Client_UnconfirmedTx_Call {
	_c.Call.Return(resultUnconfirmedTx, err)
	return _c
}

func (_c *Client_UnconfirmedTx_Call) RunAndReturn(run func(ctx context.Context, txHash []byte) (*coretypes.ResultUnconfirmedTx, error)) *Client_UnconfirmedTx_Call {
	_c.Call.Return(run)
	return _c
}

// UnconfirmedTxs provides a mock function for the type Client
func (_mock *Client) UnconfirmedTxs(ctx context.Context, page *int, perPage *int) (*coretypes.ResultUnconfirmedTxs, error) {
	ret := _mock.Called(ctx, page, perPage)

	if len(ret) == 0 {
		panic("no return value specified for UnconfirmedTxs")
	}

	var r0 *coretypes.ResultUnconfirmedTxs
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int, *int) (*coretypes.ResultUnconfirmedTxs, error)); ok {
		return returnFunc(ctx, page, perPage)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int, *int) *coretypes.ResultUnconfirmedTxs); ok {
		r0 = returnFunc(ctx, page, perPage)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultUnconfirmedTxs)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int, *int) error); ok {
		r1 = returnFunc(ctx, page, perPage)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_UnconfirmedTxs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnconfirmedTxs'
type Client_UnconfirmedTxs_Call struct {
	*mock.Call
}

// UnconfirmedTxs is a helper method to define mock.On call
//   - ctx
//   - page
//   - perPage
func (_e *Client_Expecter) UnconfirmedTxs(ctx interface{}, page interface{}, perPage interface{}) *Client_UnconfirmedTxs_Call {
	return &Client_UnconfirmedTxs_Call{Call: _e.mock.On("UnconfirmedTxs", ctx, page, perPage)}
}

func (_c *Client_UnconfirmedTxs_Call) Run(run func(ctx context.Context, page *int, perPage *int)) *Client_UnconfirmedTxs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int), args[2].(*int))
	})
	return _c
}

func (_c *Client_UnconfirmedTxs_Call) Return(resultUnconfirmedTxs *coretypes.ResultUnconfirmedTxs, err error) *Client_UnconfirmedTxs_Call {
	_c.Call.Return(resultUnconfirmedTxs, err)
	return _c
}

func (_c *Client_UnconfirmedTxs_Call) RunAndReturn(run func(ctx context.Context, page *int, perPage *int) (*coretypes.ResultUnconfirmedTxs, error)) *Client_UnconfirmedTxs_Call {
	_c.Call.Return(run)
	return _c
}

// Unsubscribe provides a mock function for the type Client
func (_mock *Client) Unsubscribe(ctx context.Context, subscriber string, query string) error {
	ret := _mock.Called(ctx, subscriber, query)

	if len(ret) == 0 {
		panic("no return value specified for Unsubscribe")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, subscriber, query)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_Unsubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unsubscribe'
type Client_Unsubscribe_Call struct {
	*mock.Call
}

// Unsubscribe is a helper method to define mock.On call
//   - ctx
//   - subscriber
//   - query
func (_e *Client_Expecter) Unsubscribe(ctx interface{}, subscriber interface{}, query interface{}) *Client_Unsubscribe_Call {
	return &Client_Unsubscribe_Call{Call: _e.mock.On("Unsubscribe", ctx, subscriber, query)}
}

func (_c *Client_Unsubscribe_Call) Run(run func(ctx context.Context, subscriber string, query string)) *Client_Unsubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Client_Unsubscribe_Call) Return(err error) *Client_Unsubscribe_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_Unsubscribe_Call) RunAndReturn(run func(ctx context.Context, subscriber string, query string) error) *Client_Unsubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeAll provides a mock function for the type Client
func (_mock *Client) UnsubscribeAll(ctx context.Context, subscriber string) error {
	ret := _mock.Called(ctx, subscriber)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, subscriber)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_UnsubscribeAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeAll'
type Client_UnsubscribeAll_Call struct {
	*mock.Call
}

// UnsubscribeAll is a helper method to define mock.On call
//   - ctx
//   - subscriber
func (_e *Client_Expecter) UnsubscribeAll(ctx interface{}, subscriber interface{}) *Client_UnsubscribeAll_Call {
	return &Client_UnsubscribeAll_Call{Call: _e.mock.On("UnsubscribeAll", ctx, subscriber)}
}

func (_c *Client_UnsubscribeAll_Call) Run(run func(ctx context.Context, subscriber string)) *Client_UnsubscribeAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Client_UnsubscribeAll_Call) Return(err error) *Client_UnsubscribeAll_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_UnsubscribeAll_Call) RunAndReturn(run func(ctx context.Context, subscriber string) error) *Client_UnsubscribeAll_Call {
	_c.Call.Return(run)
	return _c
}

// Validators provides a mock function for the type Client
func (_mock *Client) Validators(ctx context.Context, height *int64, page *int, perPage *int, requestQuorumInfo *bool) (*coretypes.ResultValidators, error) {
	ret := _mock.Called(ctx, height, page, perPage, requestQuorumInfo)

	if len(ret) == 0 {
		panic("no return value specified for Validators")
	}

	var r0 *coretypes.ResultValidators
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64, *int, *int, *bool) (*coretypes.ResultValidators, error)); ok {
		return returnFunc(ctx, height, page, perPage, requestQuorumInfo)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *int64, *int, *int, *bool) *coretypes.ResultValidators); ok {
		r0 = returnFunc(ctx, height, page, perPage, requestQuorumInfo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultValidators)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *int64, *int, *int, *bool) error); ok {
		r1 = returnFunc(ctx, height, page, perPage, requestQuorumInfo)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_Validators_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Validators'
type Client_Validators_Call struct {
	*mock.Call
}

// Validators is a helper method to define mock.On call
//   - ctx
//   - height
//   - page
//   - perPage
//   - requestQuorumInfo
func (_e *Client_Expecter) Validators(ctx interface{}, height interface{}, page interface{}, perPage interface{}, requestQuorumInfo interface{}) *Client_Validators_Call {
	return &Client_Validators_Call{Call: _e.mock.On("Validators", ctx, height, page, perPage, requestQuorumInfo)}
}

func (_c *Client_Validators_Call) Run(run func(ctx context.Context, height *int64, page *int, perPage *int, requestQuorumInfo *bool)) *Client_Validators_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64), args[2].(*int), args[3].(*int), args[4].(*bool))
	})
	return _c
}

func (_c *Client_Validators_Call) Return(resultValidators *coretypes.ResultValidators, err error) *Client_Validators_Call {
	_c.Call.Return(resultValidators, err)
	return _c
}

func (_c *Client_Validators_Call) RunAndReturn(run func(ctx context.Context, height *int64, page *int, perPage *int, requestQuorumInfo *bool) (*coretypes.ResultValidators, error)) *Client_Validators_Call {
	_c.Call.Return(run)
	return _c
}
