syntax = "proto3";
package tendermint.abci;

option go_package = "github.com/dashpay/tenderdash/abci/types";

import "tendermint/crypto/proof.proto";
import "tendermint/types/dash.proto";
import "tendermint/types/block.proto";
import "tendermint/types/types.proto";
import "tendermint/crypto/keys.proto";
import "tendermint/types/params.proto";
import "tendermint/version/types.proto";
import "google/protobuf/timestamp.proto";
import "gogoproto/gogo.proto";

// NOTE: When using custom types, mind the warnings.
//
// https://github.com/cosmos/gogoproto/blob/master/custom_types.md#warnings-and-issues
//
//----------------------------------------

// Request types
message Request {
  oneof value {
    RequestEcho                echo                  = 1;
    RequestFlush               flush                 = 2;
    RequestInfo                info                  = 3;
    RequestInitChain           init_chain            = 4;
    RequestQuery               query                 = 5;
    RequestCheckTx             check_tx              = 7;
    RequestListSnapshots       list_snapshots        = 11;
    RequestOfferSnapshot       offer_snapshot        = 12;
    RequestLoadSnapshotChunk   load_snapshot_chunk   = 13;
    RequestApplySnapshotChunk  apply_snapshot_chunk  = 14;
    RequestPrepareProposal     prepare_proposal      = 15;
    RequestProcessProposal     process_proposal      = 16;
    RequestExtendVote          extend_vote           = 17;
    RequestVerifyVoteExtension verify_vote_extension = 18;
    RequestFinalizeBlock       finalize_block        = 19;
  }
  reserved 6, 8, 9, 10;  // RequestBeginBlock, RequestDeliverTx, RequestEndBlock, RequestCommit
}
// Echo a string to test an abci client/server implementation
message RequestEcho {
  string message = 1;  // A string to echo back
}

// Signals that messages queued on the client should be flushed to the server.
// It is called periodically by the client implementation to ensure asynchronous
// requests are actually sent, and is called immediately to make a synchronous request,
// which returns when the Flush response comes back.
message RequestFlush {}

// Return information about the application state.
//
// Used to sync Tenderdash with the application during a handshake that happens on startup.
// The returned app_version will be included in the Header of every block.
// Tenderdash expects last_block_app_hash and last_block_height to be updated during Commit,
// ensuring that Commit is never called twice for the same block height.
message RequestInfo {
  string version       = 1;  // The Tenderdash software semantic version.
  uint64 block_version = 2;  // The Tenderdash Block Protocol version.
  uint64 p2p_version   = 3;  // The Tenderdash P2P Protocol version.
  string abci_version  = 4;  // The Tenderdash ABCI semantic version.
}

// Called once upon genesis.
//
// - If ResponseInitChain.Validators is empty, the initial validator set will be the RequestInitChain.Validators
// - If ResponseInitChain.Validators is not empty, it will be the initial validator set (regardless of what is in
//   RequestInitChain.Validators).
// - This allows the app to decide if it wants to accept the initial validator set proposed by Tenderdash
//   (ie. in the genesis file), or if it wants to use a different one (perhaps computed based on some application
//   specific information in the genesis file).
message RequestInitChain {
  // Genesis time
  google.protobuf.Timestamp time = 1
      [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
  // ID of the blockchain.
  string chain_id = 2;
  // Initial consensus-critical parameters.
  tendermint.types.ConsensusParams consensus_params = 3;
  // Initial genesis validators, sorted by voting power.
  ValidatorSetUpdate validator_set = 4 [(gogoproto.nullable) = true];
  // Serialized initial application state. JSON bytes.
  bytes app_state_bytes = 5;
  // Height of the initial block (typically `1`).
  int64 initial_height = 6;
  // Initial core chain lock height.
  uint32 initial_core_height = 7;
}

// Query for data from the application at current or past height.
//
// - Optionally return Merkle proof.
// - Merkle proof includes self-describing type field to support many types of Merkle trees and encoding formats.
message RequestQuery {
  // Raw query bytes. Can be used with or in lieu of Path.
  bytes data = 1;
  // Path field of the request URI. Can be used with or in lieu of data.
  // Apps MUST interpret /store as a query by key on the underlying store.
  // The key SHOULD be specified in the data field.
  // Apps SHOULD allow queries over specific types like /accounts/... or /votes/...
  string path = 2;
  // The block height for which you want the query (default=0 returns data for the latest committed block).
  // Note that this is the height of the block containing the application's Merkle root hash, which
  // represents the state as it was after committing the block at Height-1.
  int64 height = 3;
  // Return Merkle proof with response if possible.
  bool prove = 4;
}

// Type of transaction check
enum CheckTxType {
  // NEW is the default and means that a full check of the tranasaction is required.
  NEW = 0 [(gogoproto.enumvalue_customname) = "New"];
  // RECHECK is used when the mempool is initiating a normal recheck of a transaction.
  RECHECK = 1 [(gogoproto.enumvalue_customname) = "Recheck"];
}

// Check if transaction is valid.
//
// - Technically optional - not involved in processing blocks.
// - Guardian of the mempool: every node runs CheckTx before letting a transaction into its local mempool.
// - The transaction may come from an external user or another node
// - CheckTx validates the transaction against the current state of the application, for example, checking
//   signatures and account balances, but does not apply any of the state changes described in the transaction.
// - Transactions where ResponseCheckTx.Code != 0 will be rejected - they will not be broadcast to other nodes
//   or included in a proposal block.
// - Tendermint attributes no other value to the response code
message RequestCheckTx {
  // The request transaction bytes.
  bytes tx = 1;
  // Type or transaction check to execute.
  CheckTxType type = 2;
}

// Lists available snapshots
//
// - Used during state sync to discover available snapshots on peers.
// - See Snapshot data type for details.
message RequestListSnapshots {}

// Offers a snapshot to the application.
//
// - OfferSnapshot is called when bootstrapping a node using state sync. The application may accept or reject snapshots
//   as appropriate. Upon accepting, Tenderdash will retrieve and apply snapshot chunks via ApplySnapshotChunk.
//   The application may also choose to reject a snapshot in the chunk response, in which case it should be prepared
//   to accept further OfferSnapshot calls.
// - Only AppHash can be trusted, as it has been verified by the light client. Any other data can be spoofed
//   by adversaries, so applications should employ additional verification schemes to avoid denial-of-service attacks.
//   The verified AppHash is automatically checked against the restored application at the end of snapshot restoration.
// - For more information, see the Snapshot data type or the state sync section.
message RequestOfferSnapshot {
  // The snapshot offered for restoration.
  Snapshot snapshot = 1;
  // The light client-verified app hash for this height, from the blockchain. 32 bytes.
  bytes app_hash = 2;
}

// Used during state sync to retrieve snapshot chunks from peers.
message RequestLoadSnapshotChunk {
  uint64 height   = 1;  // The height of the snapshot the chunks belongs to.
  uint32 version  = 2;  // The application-specific format of the snapshot the chunk belongs to.
  bytes  chunk_id = 3;  // The chunk id is a hash of the node of subtree of the snapshot.
}

// Applies a snapshot chunk.
//
// - The application can choose to refetch chunks and/or ban P2P peers as appropriate.
//   Tenderdash will not do this unless instructed by the application.
// - The application may want to verify each chunk, e.g. by attaching chunk hashes in `Snapshot.Metadata`` and/or
//   incrementally verifying contents against AppHash.
// - When all chunks have been accepted, Tenderdash will make an ABCI Info call to verify that LastBlockAppHash
//   and LastBlockHeight matches the expected values, and record the AppVersion in the node state.
//   It then switches to fast sync or consensus and joins the network.
// - If Tenderdash is unable to retrieve the next chunk after some time (e.g. because no suitable peers are available),
//   it will reject the snapshot and try a different one via OfferSnapshot. The application should be prepared to reset
//   and accept it or abort as appropriate.
message RequestApplySnapshotChunk {
  bytes  chunk_id = 1;  // The chunk index, starting from 0. Tenderdash applies chunks sequentially.
  bytes  chunk    = 2;  // The binary chunk contents, as returned by LoadSnapshotChunk.
  string sender   = 3;  // The P2P ID of the node who sent this chunk.
}

// Prepare new block proposal, potentially altering list of transactions.
//
// #### Usage
//
// - The first six parameters of `RequestPrepareProposal` are the same as `RequestProcessProposal`
//   and `RequestFinalizeBlock`.
// - The height and time values match the values from the header of the proposed block.
// - `RequestPrepareProposal` contains a preliminary set of transactions `txs` that Tenderdash considers to be a good block proposal, called _raw proposal_. The Application can modify this set via `ResponsePrepareProposal.tx_records` (see [TxRecord](#txrecord)).
//     - The Application _can_ reorder, remove or add transactions to the raw proposal. Let `tx` be a transaction in `txs`:
//         - If the Application considers that `tx` should not be proposed in this block, e.g., there are other transactions with higher priority, then it should not include it in `tx_records`. In this case, Tenderdash won't remove `tx` from the mempool. The Application should be extra-careful, as abusing this feature may cause transactions to stay forever in the mempool.
//         - If the Application considers that a `tx` should not be included in the proposal and removed from the mempool, then the Application should include it in `tx_records` and _mark_ it as `REMOVED`. In this case, Tenderdash will remove `tx` from the mempool.
//         - If the Application wants to add a new transaction, then the Application should include it in `tx_records` and _mark_ it as `ADD`. In this case, Tenderdash will add it to the mempool.
//     - The Application should be aware that removing and adding transactions may compromise _traceability_.
//       > Consider the following example: the Application transforms a client-submitted transaction `t1` into a second transaction `t2`, i.e., the Application asks Tenderdash to remove `t1` and add `t2` to the mempool. If a client wants to eventually check what happened to `t1`, it will discover that `t_1` is not in the mempool or in a committed block, getting the wrong idea that `t_1` did not make it into a block. Note that `t_2` _will be_ in a committed block, but unless the Application tracks this information, no component will be aware of it. Thus, if the Application wants traceability, it is its responsability to support it. For instance, the Application could attach to a transformed transaction a list with the hashes of the transactions it derives from.
// - Tenderdash MAY include a list of transactions in `RequestPrepareProposal.txs` whose total size in bytes exceeds `RequestPrepareProposal.max_tx_bytes`.
//   Therefore, if the size of `RequestPrepareProposal.txs` is greater than `RequestPrepareProposal.max_tx_bytes`, the Application MUST make sure that the
//   `RequestPrepareProposal.max_tx_bytes` limit is respected by those transaction records returned in `ResponsePrepareProposal.tx_records` that are marked as `UNMODIFIED` or `ADDED`.
// - In same-block execution mode, the Application must provide values for `ResponsePrepareProposal.app_hash`,
//   `ResponsePrepareProposal.tx_results`, `ResponsePrepareProposal.validator_updates`, `ResponsePrepareProposal.core_chain_lock_update` and
//   `ResponsePrepareProposal.consensus_param_updates`, as a result of fully executing the block.
//     - The values for `ResponsePrepareProposal.validator_updates`, `ResponsePrepareProposal.core_chain_lock_update` or
//       `ResponsePrepareProposal.consensus_param_updates` may be empty. In this case, Tenderdash will keep
//       the current values.
//     - `ResponsePrepareProposal.validator_updates`, triggered by block `H`, affect validation
//       for blocks `H+1`, and `H+2`. Heights following a validator update are affected in the following way:
//         - `H`: `NextValidatorsHash` includes the new `validator_updates` value.
//         - `H+1`: The validator set change takes effect and `ValidatorsHash` is updated.
//         - `H+2`: `local_last_commit` now includes the altered validator set.
//     - `ResponseFinalizeBlock.consensus_param_updates` returned for block `H` apply to the consensus
//       params for block `H+1` even if the change is agreed in block `H`.
//       For more information on the consensus parameters,
//       see the [application spec entry on consensus parameters](../abci/apps.md#consensus-parameters).
//     - It is the responsibility of the Application to set the right value for _TimeoutPropose_ so that
//       the (synchronous) execution of the block does not cause other processes to prevote `nil` because
//       their propose timeout goes off.
// - As a result of executing the prepared proposal, the Application may produce header events or transaction events.
//   The Application must keep those events until a block is decided and then pass them on to Tenderdash via
//   `ResponsePrepareProposal`.
// - As a sanity check, Tenderdash will check the returned parameters for validity if the Application modified them.
//   In particular, `ResponsePrepareProposal.tx_records` will be deemed invalid if
//     - There is a duplicate transaction in the list.
//     - A new or modified transaction is marked as `UNMODIFIED` or `REMOVED`.
//     - An unmodified transaction is marked as `ADDED`.
//     - A transaction is marked as `UNKNOWN`.
// - `ResponsePrepareProposal.tx_results` contains only results of  `UNMODIFIED` and `ADDED` transactions.
// `REMOVED` transactions are omitted. The length of `tx_results` can be different than the length of `tx_records`.
// - If Tenderdash fails to validate the `ResponsePrepareProposal`, Tenderdash will assume the application is faulty and crash.
//     - The implementation of `PrepareProposal` can be non-deterministic.
//
// #### When does Tenderdash call it?
//
// When a validator _p_ enters Tenderdash consensus round _r_, height _h_, in which _p_ is the proposer,
// and _p_'s _validValue_ is `nil`:
//
// 1. _p_'s Tenderdash collects outstanding transactions from the mempool
//     - The transactions will be collected in order of priority
//     - Let $C$ the list of currently collected transactions
//     - The collection stops when any of the following conditions are met
//         - the mempool is empty
//         - the total size of transactions $\in C$ is greater than or equal to `consensusParams.block.max_bytes`
//         - the sum of `GasWanted` field of transactions $\in C$ is greater than or equal to
//           `consensusParams.block.max_gas`
//     - _p_'s Tenderdash creates a block header.
// 2. _p_'s Tenderdash calls `RequestPrepareProposal` with the newly generated block.
//    The call is synchronous: Tenderdash's execution will block until the Application returns from the call.
// 3. The Application checks the block (hashes, transactions, commit info, misbehavior). Besides,
//     - in same-block execution mode, the Application can (and should) provide `ResponsePrepareProposal.app_hash`,
//       `ResponsePrepareProposal.validator_updates`, or
//       `ResponsePrepareProposal.consensus_param_updates`.
//     - the Application can manipulate transactions
//         - leave transactions untouched - `TxAction = UNMODIFIED`
//         - add new transactions directly to the proposal - `TxAction = ADDED`
//         - remove transactions (invalid) from the proposal and from the mempool - `TxAction = REMOVED`
//         - remove transactions from the proposal but not from the mempool (effectively _delaying_ them) - the
//           Application removes the transaction from the list
//         - modify transactions (e.g. aggregate them) - `TxAction = ADDED` followed by `TxAction = REMOVED`. As explained above, this compromises client traceability, unless it is implemented at the Application level.
//         - reorder transactions - the Application reorders transactions in the list
// 4. If the block is modified, the Application includes the modified block in the return parameters (see the rules in section _Usage_).
//    The Application returns from the call.
// 5. _p_'s Tenderdash uses the (possibly) modified block as _p_'s proposal in round _r_, height _h_.
//
// Note that, if _p_ has a non-`nil` _validValue_, Tenderdash will use it as proposal and will not call `RequestPrepareProposal`.
message RequestPrepareProposal {
  // Currently configured maximum size in bytes taken by the modified transactions.
  // The modified transactions cannot exceed this size.
  int64 max_tx_bytes = 1;
  // Preliminary list of transactions that have been picked as part of the block to propose.
  // Sent to the app for possible modifications.
  repeated bytes txs = 2;
  // Info about the last commit, obtained locally from Tenderdash's data structures.
  CommitInfo local_last_commit = 3 [(gogoproto.nullable) = false];
  // List of information about validators that acted incorrectly.
  repeated Misbehavior misbehavior = 4 [(gogoproto.nullable) = false];
  // The height of the block that will be proposed.
  int64 height = 5;
  // Timestamp of the block that that will be proposed.
  google.protobuf.Timestamp time = 6 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
  // Merkle root of the next validator set.
  bytes next_validators_hash = 7;
  // Round number for the block.
  int32 round = 8;
  // Core chain lock height to be used when signing this block.
  uint32 core_chain_locked_height = 9;
  // ProTxHash of the original proposer of the block.
  bytes proposer_pro_tx_hash = 10;
  // Proposer's latest available app protocol version.
  uint64 proposed_app_version = 11;
  // App and block version used to generate the block.
  // App version included in the block can be modified by setting ResponsePrepareProposal.app_version.
  tendermint.version.Consensus version = 12;
  // quorum_hash contains hash of validator quorum that will sign the block
  bytes quorum_hash = 13;
}

// Process prepared proposal.
//
// #### Usage
//
// - Contains fields from the proposed block.
//     - The Application may fully execute the block as though it was handling `RequestFinalizeBlock`.
//       However, any resulting state changes must be kept as _candidate state_,
//       and the Application should be ready to backtrack/discard it in case the decided block is different.
// - The height and timestamp values match the values from the header of the proposed block.
// - If `ResponseProcessProposal.status` is `REJECT`, Tenderdash assumes the proposal received
//   is not valid.
// - In same-block execution mode, the Application is required to fully execute the block and provide values
//   for parameters `ResponseProcessProposal.app_hash`, `ResponseProcessProposal.tx_results`,
//   `ResponseProcessProposal.validator_updates`, and `ResponseProcessProposal.consensus_param_updates`,
//   so that Tenderdash can then verify the hashes in the block's header are correct.
//   If the hashes mismatch, Tenderdash will reject the block even if `ResponseProcessProposal.status`
//   was set to `ACCEPT`.
// - The implementation of `ProcessProposal` MUST be deterministic. Moreover, the value of
//   `ResponseProcessProposal.status` MUST **exclusively** depend on the parameters passed in
//   the call to `RequestProcessProposal`, and the last committed Application state
//   (see [Requirements](abci++_app_requirements.md) section).
// - Moreover, application implementors SHOULD always set `ResponseProcessProposal.status` to `ACCEPT`,
//   unless they _really_ know what the potential liveness implications of returning `REJECT` are.
//
// #### When does Tenderdash call it?
//
// When a validator _p_ enters Tenderdash consensus round _r_, height _h_, in which _q_ is the proposer (possibly _p_ = _q_):
//
// 1. _p_ sets up timer `ProposeTimeout`.
// 2. If _p_ is the proposer, _p_ executes steps 1-6 in [PrepareProposal](#prepareproposal).
// 3. Upon reception of Proposal message (which contains the header) for round _r_, height _h_ from _q_, _p_'s Tenderdash verifies the block header.
// 4. Upon reception of Proposal message, along with all the block parts, for round _r_, height _h_ from _q_, _p_'s Tenderdash follows its algorithm
//    to check whether it should prevote for the block just received, or `nil`
// 5. If Tenderdash should prevote for the block just received
//     1. Tenderdash calls `RequestProcessProposal` with the block. The call is synchronous.
//     2. The Application checks/processes the proposed block, which is read-only, and returns true (_accept_) or false (_reject_) in `ResponseProcessProposal.accept`.
//        - The Application, depending on its needs, may call `ResponseProcessProposal`
//          - either after it has completely processed the block (the simpler case),
//          - or immediately (after doing some basic checks), and process the block asynchronously. In this case the Application will
//            not be able to reject the block, or force prevote/precommit `nil` afterwards.
//     3. If the returned value is
//          - _accept_, Tenderdash prevotes on this proposal for round _r_, height _h_.
//          - _reject_, Tenderdash prevotes `nil`.
message RequestProcessProposal {
  // List of transactions that have been picked as part of the proposed
  repeated bytes txs = 1;
  // Info about the last commit, obtained from the information in the proposed block.
  CommitInfo proposed_last_commit = 2 [(gogoproto.nullable) = false];
  // List of information about validators that acted incorrectly.
  repeated Misbehavior misbehavior = 3 [(gogoproto.nullable) = false];
  // The block header's hash of the proposed block.
  // It is computed as a Merkle tree from the header fields.
  bytes hash = 4;
  // The height of the proposed block.
  int64 height = 5;
  // Round number for the block
  int32 round = 6;
  // Timestamp included in the proposed block.
  google.protobuf.Timestamp time = 7 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
  // Merkle root of the next validator set.
  bytes next_validators_hash = 8;
  // Core chain lock height to be used when signing this block.
  uint32 core_chain_locked_height = 9;
  // Next core-chain-lock-update for validation in ABCI.
  tendermint.types.CoreChainLock core_chain_lock_update = 10;
  // ProTxHash of the original proposer of the block.
  bytes proposer_pro_tx_hash = 11;
  // Proposer's latest available app protocol version.
  uint64 proposed_app_version = 12;
  // App and block version used to generate the block.
  // App version MUST be verified by the app.
  tendermint.version.Consensus version = 13;
  // quorum_hash contains hash of validator quorum that will sign the block
  bytes quorum_hash = 14;
}

// Extends a vote with application-side injection
//
// #### Usage
//
// - `ResponseExtendVote.vote_extensions` is optional information that, if present, will be signed by Tenderdash and
//   attached to the Precommit message.
// - `RequestExtendVote.hash` corresponds to the hash of a proposed block that was made available to the application
//   in a previous call to `ProcessProposal` or `PrepareProposal` for the current height.
// - `ResponseExtendVote.vote_extensions` will only be attached to a non-`nil` Precommit message. If Tenderdash is to
//   precommit `nil`, it will not call `RequestExtendVote`.
// - The Application logic that creates the extensions can be non-deterministic.
//
// #### When does Tenderdash call it?
//
// When a validator _p_ is in Tenderdash consensus state _prevote_ of round _r_, height _h_, in which _q_ is the proposer; and _p_ has received
//
// - the Proposal message _v_ for round _r_, height _h_, along with all the block parts, from _q_,
// - `Prevote` messages from _2f + 1_ validators' voting power for round _r_, height _h_, prevoting for the same block _id(v)_,
//
// then _p_'s Tenderdash locks _v_  and sends a Precommit message in the following way
//
// 1. _p_'s Tenderdash sets _lockedValue_ and _validValue_ to _v_, and sets _lockedRound_ and _validRound_ to _r_
// 2. _p_'s Tenderdash calls `RequestExtendVote` with _id(v)_ (`RequestExtendVote.hash`). The call is synchronous.
// 3. The Application optionally returns an array of bytes, `ResponseExtendVote.extension`, which is not interpreted by Tenderdash.
// 4. _p_'s Tenderdash includes `ResponseExtendVote.extension` in a field of type [CanonicalVoteExtension](#canonicalvoteextension),
//    it then populates the other fields in [CanonicalVoteExtension](#canonicalvoteextension), and signs the populated
//    data structure.
// 5. _p_'s Tenderdash constructs and signs the [CanonicalVote](../core/data_structures.md#canonicalvote) structure.
// 6. _p_'s Tenderdash constructs the Precommit message (i.e. [Vote](../core/data_structures.md#vote) structure)
//    using [CanonicalVoteExtension](#canonicalvoteextension) and [CanonicalVote](../core/data_structures.md#canonicalvote).
// 7. _p_'s Tenderdash broadcasts the Precommit message.
//
// In the cases when _p_'s Tenderdash is to broadcast `precommit nil` messages (either _2f+1_ `prevote nil` messages received,
// or _timeoutPrevote_ triggered), _p_'s Tenderdash does **not** call `RequestExtendVote` and will not include
// a [CanonicalVoteExtension](#canonicalvoteextension) field in the `precommit nil` message.
message RequestExtendVote {
  bytes hash   = 1;  // The header hash of the proposed block that the vote extensions is to refer to.
  int64 height = 2;  // Height of the proposed block (for sanity check).
  int32 round  = 3;  // // Round number for the block.
}

// Verify the vote extension
//
// #### Usage
//
// - `RequestVerifyVoteExtension.vote_extension` can be an empty byte array. The Application's interpretation of it should be
//   that the Application running at the process that sent the vote chose not to extend it.
//   Tenderdash will always call `RequestVerifyVoteExtension`, even for 0 length vote extensions.
// - If `ResponseVerifyVoteExtension.status` is `REJECT`, Tenderdash will reject the whole received vote.
//   See the [Requirements](abci++_app_requirements.md) section to understand the potential
//   liveness implications of this.
// - The implementation of `VerifyVoteExtension` MUST be deterministic. Moreover, the value of
//   `ResponseVerifyVoteExtension.status` MUST **exclusively** depend on the parameters passed in
//   the call to `RequestVerifyVoteExtension`, and the last committed Application state
//   (see [Requirements](abci++_app_requirements.md) section).
// - Moreover, application implementers SHOULD always set `ResponseVerifyVoteExtension.status` to `ACCEPT`,
//   unless they _really_ know what the potential liveness implications of returning `REJECT` are.
//
// #### When does Tenderdash call it?
//
// When a validator _p_ is in Tenderdash consensus round _r_, height _h_, state _prevote_ (**TODO** discuss: I think I must remove the state
// from this condition, but not sure), and _p_ receives a Precommit message for round _r_, height _h_ from _q_:
//
// 1. If the Precommit message does not contain a vote extensions with a valid signature, Tenderdash discards the message as invalid.
//   - a 0-length vote extensions is valid as long as its accompanying signature is also valid.
// 2. Else, _p_'s Tenderdash calls `RequestVerifyVoteExtension`.
// 3. The Application returns _accept_ or _reject_ via `ResponseVerifyVoteExtension.status`.
// 4. If the Application returns
//   - _accept_, _p_'s Tenderdash will keep the received vote, together with its corresponding
//     vote extension in its internal data structures. It will be used to populate the [ExtendedCommitInfo](#extendedcommitinfo)
//     structure in calls to `RequestPrepareProposal`, in rounds of height _h + 1_ where _p_ is the proposer.
//   - _reject_, _p_'s Tenderdash will deem the Precommit message invalid and discard it.
//
message RequestVerifyVoteExtension {
  bytes hash                  = 1;  // The header hash of the propsed block that the vote extensions refers to.
  bytes validator_pro_tx_hash = 2;  // ProTxHash of the validator that signed the extensions.
  int64 height                = 3;  // Height of the block (for sanity check).
  int32 round                 = 4;  // // Round number for the block.
  // Application-specific information signed by Tenderdash. Can have 0 length.
  repeated ExtendVoteExtension vote_extensions = 5;
}

// Finalize newly decided block.
//
// #### Usage
//
// - Contains the fields of the newly decided block.
// - The height and timestamp values match the values from the header of the proposed block.
// - The Application can use `RequestFinalizeBlock.decided_last_commit` and `RequestFinalizeBlock.byzantine_validators`
//   to determine rewards and punishments for the validators.
// - The application must execute the transactions in full, in the order they appear in `RequestFinalizeBlock.txs`,
//   before returning control to Tenderdash. Alternatively, it can commit the candidate state corresponding to the same block
//   previously executed via `PrepareProposal` or `ProcessProposal`.
// - If ProcessProposal for the same arguments have succeeded, FinalizeBlock MUST always succeed.
// - Application is expected to persist its state at the end of this call, before returning `ResponseFinalizeBlock`.
// - Later calls to `Query` can return proofs about the application state anchored
//   in this Merkle root hash.
// - Use `ResponseFinalizeBlock.retain_height` with caution! If all nodes in the network remove historical
//   blocks then this data is permanently lost, and no new nodes will be able to join the network and
//   bootstrap. Historical blocks may also be required for other purposes, e.g. auditing, replay of
//   non-persisted heights, light client verification, and so on.
// - Just as `ProcessProposal`, the implementation of `FinalizeBlock` MUST be deterministic, since it is
//   making the Application's state evolve in the context of state machine replication.
// - Currently, Tenderdash will fill up all fields in `RequestFinalizeBlock`, even if they were
//   already passed on to the Application via `RequestPrepareProposal` or `RequestProcessProposal`.
//   If the Application is in same-block execution mode, it applies the right candidate state here
//   (rather than executing the whole block). In this case the Application disregards all parameters in
//   `RequestFinalizeBlock` except `RequestFinalizeBlock.hash`.
message RequestFinalizeBlock {
  // Info about the current commit
  CommitInfo commit = 1 [(gogoproto.nullable) = false];
  // List of information about validators that acted incorrectly.
  repeated Misbehavior misbehavior = 2 [(gogoproto.nullable) = false];
  // The block header's hash. Present for convenience (can be derived from the block header).
  bytes hash = 3;
  // The height of the finalized block.
  int64 height = 4;
  // Round number for the block
  int32 round = 5;
  // The block that was finalized
  tendermint.types.Block block = 6;
  // The block ID that was finalized
  tendermint.types.BlockID block_id = 7 [(gogoproto.customname) = "BlockID"];
}

//----------------------------------------
// Response types

message Response {
  oneof value {
    ResponseException           exception             = 1;
    ResponseEcho                echo                  = 2;
    ResponseFlush               flush                 = 3;
    ResponseInfo                info                  = 4;
    ResponseInitChain           init_chain            = 5;
    ResponseQuery               query                 = 6;
    ResponseCheckTx             check_tx              = 7;
    ResponseListSnapshots       list_snapshots        = 8;
    ResponseOfferSnapshot       offer_snapshot        = 9;
    ResponseLoadSnapshotChunk   load_snapshot_chunk   = 10;
    ResponseApplySnapshotChunk  apply_snapshot_chunk  = 11;
    ResponsePrepareProposal     prepare_proposal      = 12;
    ResponseProcessProposal     process_proposal      = 13;
    ResponseExtendVote          extend_vote           = 14;
    ResponseVerifyVoteExtension verify_vote_extension = 15;
    ResponseFinalizeBlock       finalize_block        = 16;
  }
}

// nondeterministic
message ResponseException {
  string error = 1;
}

message ResponseEcho {
  string message = 1;  // The input string.
}

message ResponseFlush {}

message ResponseInfo {
  string data                = 1;  // Some arbitrary information.
  string version             = 2;  // The application software semantic version.
  uint64 app_version         = 3;  // The application protocol version.
  int64  last_block_height   = 4;  // Latest block for which the app has called Commit.
  bytes  last_block_app_hash = 5;  // Latest result of Commit. 32 bytes.
}

message ResponseInitChain {
  // Initial consensus-critical parameters (optional).
  tendermint.types.ConsensusParams consensus_params = 1;
  // Initial application hash. 32 bytes.
  bytes app_hash = 2;
  // Initial validator set (optional).
  ValidatorSetUpdate validator_set_update = 3 [(gogoproto.nullable) = false];
  // Initial core chain lock update.
  tendermint.types.CoreChainLock next_core_chain_lock_update = 4;
  // Initial height of core lock.
  uint32 initial_core_height = 5;
  // Override genesis time with provided time.
  optional google.protobuf.Timestamp genesis_time = 6 [(gogoproto.nullable) = true, (gogoproto.stdtime) = true];
}

//
message ResponseQuery {
  uint32 code  = 1;  // Response code.
  string log   = 2;  // The output of the application's logger. **May be non-deterministic.**
  string info  = 3;  // Additional information. **May be non-deterministic.**
  int64  index = 4;  // The index of the key in the tree.
  bytes  key   = 5;  // The key of the matching data.
  bytes  value = 6;  // The value of the matching data.
  // Serialized proof for the value data, if requested, to be verified against the `app_hash` for the given Height.
  tendermint.crypto.ProofOps proof_ops = 7;
  // The block height from which data was derived. Note that this is the height of the block containing the
  // application's Merkle root hash, which represents the state as it was after committing the block at Height-1.
  int64 height = 8;
  // Namespace for the `code`.
  string codespace = 9;
}

message ResponseCheckTx {
  uint32 code       = 1;  // Response code.
  bytes  data       = 2;  // Result bytes, if any.
  string info       = 3;  // Additional information. **May be non-deterministic.**
  int64  gas_wanted = 4;  // Amount of gas requested for transaction.
  string codespace  = 5;  // Namespace for the `code`.
  string sender     = 6;  // The transaction's sender (e.g. the signer).
  int64  priority   = 7;  // The transaction's priority (for mempool ordering).
}

message ResponseListSnapshots {
  repeated Snapshot snapshots = 1;  // List of local state snapshots.
}

message ResponseOfferSnapshot {
  Result result = 1;  // The result of the snapshot offer.

  enum Result {
    UNKNOWN       = 0;  // Unknown result, abort all snapshot restoration
    ACCEPT        = 1;  // Snapshot accepted, apply chunks
    ABORT         = 2;  // Abort all snapshot restoration
    REJECT        = 3;  // Reject this specific snapshot, try others
    REJECT_FORMAT = 4;  // Reject all snapshots of this format, try others
    REJECT_SENDER = 5;  // Reject all snapshots from the sender(s), try others
  }
}

message ResponseLoadSnapshotChunk {
  // The binary chunk contents, in an arbitray format. Chunk messages cannot be larger than 16 MB _including metadata_,
  // so 10 MB is a good starting point.
  bytes chunk = 1;
}

message ResponseApplySnapshotChunk {
  Result result = 1;  // The result of applying this chunk.
  // Refetch and reapply the given chunks, regardless of `result`.
  // Only the listed chunks will be refetched, and reapplied in sequential order.
  repeated bytes refetch_chunks = 2;
  // Reject the given P2P senders, regardless of `Result`. Any chunks already applied will not be refetched
  // unless explicitly requested, but queued chunks from these senders will be discarded, and new chunks
  // or other snapshots rejected.
  repeated string reject_senders = 3;
  // Next chunks provides the list of chunks that should be requested next, if any.
  repeated bytes next_chunks = 4;

  enum Result {
    UNKNOWN           = 0;  // Unknown result, abort all snapshot restoration
    ACCEPT            = 1;  // Chunk successfully accepted
    ABORT             = 2;  // Abort all snapshot restoration
    RETRY             = 3;  // Retry chunk (combine with refetch and reject)
    RETRY_SNAPSHOT    = 4;  // Retry snapshot (combine with refetch and reject)
    REJECT_SNAPSHOT   = 5;  // Reject this snapshot, try others
    COMPLETE_SNAPSHOT = 6;  // Complete this snapshot, no more chunks
  }
}

message ResponsePrepareProposal {
  // Possibly modified list of transactions that have been picked as part of the proposed block.
  repeated TxRecord tx_records = 1;
  // The Merkle root hash of the application state. 32 bytes.
  bytes app_hash = 2;
  // List of structures containing the data resulting from executing the transactions.
  repeated ExecTxResult tx_results = 3;
  // Changes to consensus-critical gas, size, and other parameters that will be applied at next height.
  tendermint.types.ConsensusParams consensus_param_updates = 4;
  // Core chain lock that will be used for next block.
  tendermint.types.CoreChainLock core_chain_lock_update = 5;
  // Changes to validator set that will be applied at next height.
  ValidatorSetUpdate validator_set_update = 6 [(gogoproto.nullable) = true];
  // Application version that was used to create the current proposal.
  uint64 app_version = 7;
}

message ResponseProcessProposal {
  // `enum` that signals if the application finds the proposal valid.
  ProposalStatus status = 1;

  enum ProposalStatus {
    UNKNOWN = 0;  // Unspecified error occurred
    ACCEPT  = 1;  // Proposal accepted
    REJECT  = 2;  // Proposal is not valid; prevoting `nil`
  }

  // The Merkle root hash of the application state. 32 bytes.
  bytes app_hash = 2;
  // List of structures containing the data resulting from executing the transactions.
  repeated ExecTxResult tx_results = 3;
  // Changes to consensus-critical gas, size, and other parameters.
  tendermint.types.ConsensusParams consensus_param_updates = 4;

  // Changes to validator set (set voting power to 0 to remove).
  ValidatorSetUpdate validator_set_update = 5 [(gogoproto.nullable) = true];

  // Type & Key-Value events for indexing
  repeated Event events = 6 [(gogoproto.nullable) = false, (gogoproto.jsontag) = "events,omitempty"];
}

// Provides a vote extension for signing. `type` and `extension` fields are mandatory for filling
message ExtendVoteExtension {
  // Vote extension type can be either DEFAULT, THRESHOLD_RECOVER or THRESHOLD_RECOVER_RAW.
  // The Tenderdash supports only THRESHOLD_RECOVER and THRESHOLD_RECOVER_RAW at this moment.
  tendermint.types.VoteExtensionType type = 1;
  // Deterministic or (Non-Deterministic) extension provided by the sending validator's Application.
  //
  // For THRESHOLD_RECOVER_RAW, it MUST be 32 bytes.
  bytes extension = 2;
  // Sign request ID that will be used to sign the vote extensions.
  // Only applicable for THRESHOLD_RECOVER_RAW vote extension type.
  //
  // Tenderdash will use SHA256 checksum of `sign_request_id` when generating quorum signatures of
  // THRESHOLD_RECOVER_RAW vote extensions. It MUST NOT be set for any other vote extension types.

  // If not set, Tenderdash will generate it based on height and round.
  //
  // If set, it SHOULD be unique per voting round, and it MUST start with `dpevote` or `\x06plwdtx` prefix.
  //
  // Use with caution - it can have severe security consequences.
  optional bytes sign_request_id = 3;
}

message ResponseExtendVote {
  repeated ExtendVoteExtension vote_extensions = 1;  // Optional information signed by Tenderdash.
}

message ResponseVerifyVoteExtension {
  VerifyStatus status = 1;  // `enum` signaling if the application accepts the vote extension

  enum VerifyStatus {
    UNKNOWN = 0;
    ACCEPT  = 1;
    REJECT  = 2;
  }
}

message ResponseFinalizeBlock {
  // Events are moved to ProcessProposal
  reserved "events";
  reserved 1;

  // Blocks below this height may be removed. Defaults to `0` (retain all).
  int64 retain_height = 2;
}

//----------------------------------------
// Misc.

message CommitInfo {
  int32    round                                                    = 1;
  bytes    quorum_hash                                              = 2;
  bytes    block_signature                                          = 3;
  repeated tendermint.types.VoteExtension threshold_vote_extensions = 4;
}

// Event allows application developers to attach additional information to
// ResponseCheckTx, ResponsePrepareProposal, ResponseProcessProposal
// and ResponseFinalizeBlock.
//
// Later, transactions may be queried using these events.
message Event {
  string                  type       = 1;
  repeated EventAttribute attributes = 2 [(gogoproto.nullable) = false, (gogoproto.jsontag) = "attributes,omitempty"];
}

// EventAttribute is a single key-value pair, associated with an event.
message EventAttribute {
  string key   = 1;
  string value = 2;
  bool   index = 3;  // nondeterministic
}

// ExecTxResult contains results of executing one individual transaction.
message ExecTxResult {
  uint32 code = 1;  // Response code within codespace; by convention, 0 means success.
  bytes  data = 2;  // Result bytes, if any (arbitrary data, not interpreted by Tenderdash).
  string log  = 3;  // The output of the application's logger. May be non-deterministic.
  string info = 4;  // Additional information. May be non-deterministic.
  reserved "gas_wanted";
  reserved 5;
  int64 gas_used = 6;  // Amount of gas consumed by transaction.
  // Type & Key-Value events for indexing transactions (e.g. by account).
  repeated Event events = 7
      [(gogoproto.nullable) = false, (gogoproto.jsontag) = "events,omitempty"];
  string codespace = 8;  // Namespace for the code.
}

// TxResult contains results of executing the transaction.
//
// One usage is indexing transaction results.
message TxResult {
  int64        height = 1;
  uint32       index  = 2;
  bytes        tx     = 3;
  ExecTxResult result = 4 [(gogoproto.nullable) = false];
}

message TxRecord {
  TxAction action = 1;  // What should Tenderdash do with this transaction?
  bytes    tx     = 2;  // Transaction contents.

  // TxAction contains App-provided information on what to do with a transaction that is part of a raw proposal
  enum TxAction {
    UNKNOWN    = 0;  // Unknown action
    UNMODIFIED = 1;  // The Application did not modify this transaction.
    ADDED      = 2;  // The Application added this transaction.
    REMOVED    = 3;  // The Application wants this transaction removed from the proposal and the mempool.
    DELAYED    = 4;  // The Application wants this transaction removed from the proposal but not the mempool.
  }
}

//----------------------------------------
// Blockchain Types

// Validator
message Validator {
  int64 power       = 1;  // The voting power
  bytes pro_tx_hash = 2;
}

// ValidatorUpdate
message ValidatorUpdate {
  tendermint.crypto.PublicKey pub_key     = 1 [(gogoproto.nullable) = true];
  int64                       power       = 2;
  bytes                       pro_tx_hash = 3;
  // node_address is an URI containing address of validator (`proto://node_id@ip_address:port`), for example:
  //   `tcp://f2dbd9b0a1f541a7c44d34a58674d0262f5feca5@12.34.5.6:1234`
  string node_address = 4 [(gogoproto.nullable) = true];
}

// ValidatorSetUpdate represents a change in the validator set.
// It can be used to add, remove, or update a validator.
//
// Validator set update consists of multiple ValidatorUpdate records,
// each of them can be used to add, remove, or update a validator, according to the
// following rules:
//
// 1. If a validator with the same public key already exists in the validator set
// and power is greater than 0, the existing validator will be updated with the new power.
// 2. If a validator with the same public key already exists in the validator set
// and power is 0, the existing validator will be removed from the validator set.
// 3. If a validator with the same public key does not exist in the validator set and the power is greater than 0,
// a new validator will be added to the validator set.
// 4. As a special case, if quorum hash has changed, all existing validators will be removed before applying
// the new validator set update.
message ValidatorSetUpdate {
  repeated ValidatorUpdate    validator_updates    = 1 [(gogoproto.nullable) = false];
  tendermint.crypto.PublicKey threshold_public_key = 2 [(gogoproto.nullable) = false];
  bytes                       quorum_hash          = 3;
}

message ThresholdPublicKeyUpdate {
  tendermint.crypto.PublicKey threshold_public_key = 1 [(gogoproto.nullable) = false];
}

message QuorumHashUpdate {
  bytes quorum_hash = 1;
}

// VoteInfo
message VoteInfo {
  Validator validator         = 1 [(gogoproto.nullable) = false];
  bool      signed_last_block = 2;
}

// ExtendedVoteInfo
message ExtendedVoteInfo {
  // The validator that sent the vote.
  Validator validator = 1 [(gogoproto.nullable) = false];
  // Indicates whether the validator signed the last block, allowing for rewards based on validator availability.
  bool signed_last_block = 2;
  // Non-deterministic extension provided by the sending validator's application.
  bytes vote_extension = 3;
}

enum MisbehaviorType {
  UNKNOWN             = 0;
  DUPLICATE_VOTE      = 1;
  LIGHT_CLIENT_ATTACK = 2;
}

message Misbehavior {
  MisbehaviorType type = 1;
  // The offending validator
  Validator validator = 2 [(gogoproto.nullable) = false];
  // The height when the offense occurred
  int64 height = 3;
  // The corresponding time where the offense occurred
  google.protobuf.Timestamp time = 4 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
  // Total voting power of the validator set in case the ABCI application does
  // not store historical validators.
  // https://github.com/tendermint/tendermint/issues/4581
  int64 total_voting_power = 5;
}

//----------------------------------------
// State Sync Types

message Snapshot {
  uint64 height   = 1;  // The height at which the snapshot was taken
  uint32 version  = 2;  // The application-specific snapshot version
  bytes  hash     = 4;  // Arbitrary snapshot hash, equal only if identical
  bytes  metadata = 5;  // Arbitrary application metadata
}

//----------------------------------------
// Service Definition

service ABCIApplication {
  // Echo a string to test an abci client/server implementation
  rpc Echo(RequestEcho) returns (ResponseEcho);
  rpc Flush(RequestFlush) returns (ResponseFlush);
  rpc Info(RequestInfo) returns (ResponseInfo);
  rpc CheckTx(RequestCheckTx) returns (ResponseCheckTx);
  rpc Query(RequestQuery) returns (ResponseQuery);
  rpc InitChain(RequestInitChain) returns (ResponseInitChain);
  rpc ListSnapshots(RequestListSnapshots) returns (ResponseListSnapshots);
  rpc OfferSnapshot(RequestOfferSnapshot) returns (ResponseOfferSnapshot);
  rpc LoadSnapshotChunk(RequestLoadSnapshotChunk) returns (ResponseLoadSnapshotChunk);
  rpc ApplySnapshotChunk(RequestApplySnapshotChunk) returns (ResponseApplySnapshotChunk);
  rpc PrepareProposal(RequestPrepareProposal) returns (ResponsePrepareProposal);
  rpc ProcessProposal(RequestProcessProposal) returns (ResponseProcessProposal);
  rpc ExtendVote(RequestExtendVote) returns (ResponseExtendVote);
  rpc VerifyVoteExtension(RequestVerifyVoteExtension) returns (ResponseVerifyVoteExtension);
  rpc FinalizeBlock(RequestFinalizeBlock) returns (ResponseFinalizeBlock);
}
